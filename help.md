## C Primer Plus Six Edition
### chapter1:初识C语言
- 目标代码、可执行文件和库
> 将源代码编译成可执行文件:源代码经过编译器编译为目标代，链接器将目标代码，启动代码以及库代码合成一个文件，即可执行文件，被计算机识别执行
> 编译器会创建一个与源代码基本名称相同的目标代码文件，扩展名为.o,一旦连接器生成了可执行文件就会删除目标代码文件，如果源代码文件有多个，则会保留目标代码文件

- 可移植性
> 完美的可移植性程序是指，其源代码无需修改的情况下就能在不同的计算机系统中成功的编译的程序

- 源代码、目标代码、可执行文件的区别
> 源代码文件包含程序员使用的任何语言编写的代码，目标代码文件包含及其语言代码，他不是完整的程序代码
> 而可执行文件包含组成可执行文件的完整机器语言代码

- 编程的7个步骤
> 定义程序目标 设计程序 编写程序 编译程序 运行程序 测试和调整程序 维护和修改程序

- 编译器的作用
> 编译器把源代码翻译成等价的及其语言代码（也叫目标代码）

- 链接器的作用
> 链接器把编译器翻译好的源代码以及库代码和启动代码组合起来，生成一个可执行程序
### chapter2:C语言概述
- 典型的C程序组成部分
  ```
    1:#include--->预处理指令
    2:int main(void)--->main()总是第一个被调用的函数
    3:function a()、function b()-->函数是C程序的构造块
        包含语句
        C语言中的6中语句:1：标号语句
                      2：复合语句
                      3：表达式语句
                      4：选择语句
                      5：迭代语句
                      6：跳转语句
        由关键字、标识符、运算符、数据组成
  ```
- C语言的基本模块是什么
> 他们都叫做函数

### chapter3:数据和C
- 计算机得存储方式
> 整数类型和浮点数类型 int long short unsigned signed void char float double _Bool _Complex _Imaginary
- unsigned与signed的区别
> unsigned用于表示无符号位数据，其将符号位化为二进制，用于非负值的场合，标识的数值比有符号位要大
> 同时signed强调使用有符号类型的意图：比如：short   short int    signed short int     signed short都表示的是同一种类型
> 其他辅助int类型的比如 long int / long long int
- 为什么使用多种整数类型
> C语言规定short占用的存储空间不能比int多，long占用的存储空间不能比int少
> 现代计算机最常见的设置是long long占用64位，long占用32位，short占用16位，int占用16、32位，依据计算机的自然字长而定
> l/L后缀表示long类型 ll/LL后缀表示long long类型，可以用作10，8，16这些不同进制的整数
> u/U后缀表示unsigned long long 例如：5ull 8llu 11ULL 7LLU
- 打印short、long、long long和unsigned类型
> 打印unsigned int类型使用%u,打印long类型的使用%ld,%lx表示以16进制格式打印long类型
> %lo表示以8进制格式打印long类型整数
> 对于short类型，%hd表示以10进制显示short类型整数，%ho表示以8进制显示，%hx
> h和l前缀都可以和u一起使用，用于表示无符号类型，例如：%lu表示打印unsigned long类型
> %llu,%lld分别表示无符号，有符号 long long类型数据
> 虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写(格式化响应类型数据时可以使用规则内的大小写切换)
> 例如L/l 0x/0X 
- 字符常量
> 在C语言中，用单引号括起来的单个字符被称为字符常量,双引号括起来的成为字符串
> 实际上，字符是以数值形式储存的，所以也可使用数字代码值来赋值
> char grade = 'A';==》char grade = 65
- 用八进制或十六进制表示字符
> beep='\a'==>beep='\007'
> beeps='\x010'==>beeps='\X10'
> 八进制使用反斜杠\+1-3位数字  十六进制使用\x+1-3位数字
- 有符号还是无符号
> 有些C编译器把char实现为有符号类型，这意味着char可表示的范围 
> 是-128～127。而有些C编译器把char实现为无符号类型，那么char可表示的 
> 范围是0～255。根据C90标准，C语言允许在关键字char前面使用signed或unsigned。
> 这样，无论编译器默认char是什么类型，signed  char表示有符号类型，
> 而unsigned  char表示无符号类型。这在用char类型处理小整数时很有用。
> 如果只用char处理字符，那么char前面无需使用任何修饰符。
- float,double,long double
> c语言规定float类型必须至少能够表示6位有效数字，且取值范围至少是10 -37 ～10 +37
> double类型浮点数为双精度数，他和float最小取值范围相同，但是至少必须能表示10位有效数字
> 一般情况下double占用64位而不是32位
- 浮点数常量
> 浮点型常量得基本形式是：有符号得数字（包括小数点），后面紧跟e/E,最后是一个有符号数表示10的指数
> -2.1E+12   2.334e3 2.3    2.   .3  .4e-6   
> 正号可以省略，可以没有小数点或指数部分，但不能同时省略两者，可以省略小数或整数部分，但不能同时省略2者
- 打印浮点数值
> %f 打赢十进制计数法浮点数  %e打印指数计数法浮点数  %a，%A打印16进制
> 打印long double需要使用%Lf %Le %La
- 浮点数的上溢和下溢
> 当计算导致数字过 大，超过当前类型能表达的范围时，就会发生上溢,
> C语言规定，在这种情况下会赋一个表示无穷大的特定值，而且printf()显示该值为inf或infinity
> float类型的数以指数和尾数部分来储存,假设存在一个最小的浮点数，即指数部分是最小值，其他的全部位数表示最小的位数值
> 现在将该值除以2，理论上这个操作会减小指数值，，但是指数值已经是最小的了，计算机只能将后面的尾数值向右位移一位，左边
> 空出一个二进制位，并丢弃最右边的一位二进制数，虽然得到了结果，
> 但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫 作下溢（underflow）
> 因此，把最小的正浮点数除以 2将得到一个低于正常的值。如果除以一个非常大的值，会导致所有的位都为0
- 复数和虚数类型
> 简而言之，C语言有三种复数类型：float_Complex,double_Complex,long double_Complex
> 例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部
> C语言的三种虚数类型：float_Imaginary,double_Imaginary,long double_Imaginary
- 小结：基本数据类型
```
 关键字：
  基本数据类型由11个关键字组成：int,long,char,short,unsigned,float,double,signed
  _Bool,_Complex,_Imaginary
 有符号整形：
  有符号整形可以表示正整数和负整数
  int->系统给定的基本整数类型，C语言规定int类型不小于16位
  short/short int->最大的short类型整数小于或等于最大的int类型整数，C语言规定short类型至少占16位
  long/long int->该类型表示的整数大于或等于最大的int类型整数,long至少占32位
  long long/long long int->该类型可表示的整数大于或等于最大的long型整数，long long至少占64位
  一般而言：long类型占用的内存比short大，int类型的宽度要么和long相同，要么和short相同，旧DOS系统的PC提供16位的
  short和int，以及32位的long；Windows 95系统提供16位的short以及32位的int和long
 无符号型：
  无符号整形只能表示正数和零，因此可表示的正整数要比有符号的大，在整形类型前面加上unsigned即可
 字符类型：
  可打印出来的符号都是字符，char类型表示一个字符需要占用一个字节内存，处于历史原因，一个字节通常是8位，但是如果要表示基本字符
  也可以是16位或者更大
  char->字符类型的关键字，有些编译器使用有符号的char,有些使用无符号的char,在需要是可以明确定义 signed unsigned
 布尔类型：
  true/false C语言使用1表示true,0表示false
  _Bool->布尔类型的关键字，是无符号的int类型，占用的空间只要能存储0、1即可
 实浮点类型：
  表示正浮点数和负浮点数，float->系统的基本浮点类型，可精确表示至少6位有效数字
  double->存储浮点数的范围更大，能表示比float类型更多的有效数字（至少10位，通常更多）和更大的指数
  long long->存储浮点数的范围可能比double更大，能表示比double更多的有效数字和更大的指数
 复数和虚数浮点数
  虚数类型是可选的，复数的实部和虚部类型都是基于实浮点数来构建的
  float_Complex,double_Complex,long double_Complex
  float_Imaginary,double_Imaganiary,long double_Imaginary  
  小结：如何声明简单变量
  1：选择需要的类型
  2：使用有效的字符给变量起一个名字
  3：按照以下格式声明：
    类型说明符 变量名；
    说明符由一个或多个关键字组成
      unsigned int errs;
  4：可以同时声明多个同类型变量，用逗号分割变量名，如下所示：
    char chs,intss,ans;
  5：在声明的同时还可以初始化变量：
     float mass=3.14E12
```
- 刷新输出
> printf()何时将输出发送到屏幕上？最初printf()语句将输出发送到一个叫做缓冲区（buffer）的
> 中间存储区域，然后缓冲区的内容再不断发送到屏幕上，C标准规定，缓冲区满，遇到换行字符串或者需要输入的时候
> 需要刷新缓冲区（从缓冲区把数据发送到屏幕或文件），还有一种方法就是使用刷新函数fflush()

### chapter4:字符串和格式化输入输出
- char类型数组和null字符
> c语言没有专门的存储字符串的变量类型，字符串都被存储在char类型的数组中，数组由连续的存储单元组成
> 数组的末尾若没有字符就是空字符，用\0表示，空字符不是0，他是非打印字符，其ascii码值是（或等价于）0
> c的字符串一定是以空字符结尾，这意味着数组容量必须至少比带存储的字符串中的字符数多1，
> 数组是同类型数据元素的有序序列

- 使用字符串
> 字符串常量"X",和字符常量‘X’不同：1：‘x’是基本数据类型char,"x"是派生类型（char数组）
> 2：“x”实际上是由两个字符组成：‘x’和‘\0’,以空字符作为字符串的结束
- strlen()函数
> sizeof运算符，他以字节为单位给出对象大小，strlen()给出字符串中的字符长度
> C99 和 C11 标准专门为 sizeof 运算符的返回类型添加 了%zd 转换说明，这对于strlen()同样适用。
> 对于早期的C，还要知道sizeof和strlen()返回的实际类型（通常是unsigned或unsigned long）
- sizeof
> 对于sizeof有时候使用括号，有时候不使用，使用预付取决于对象是类型还是特定量
> 当对象是类型时需要使用: sizeof(int),sizeof(char)
> 当对象是特定量时，可以不使用：sizeof name ;sizeof 6.28 
- 常量和c预处理器
> 变量，c语言可能会无意间修改了值，，对于常量，c提供了一个更好的方案，c预处理器，预处理器也可以用来定义常量，
> 只需在程序顶部添加一行 #define TEXTAREA 0.16,编译程序时，程序中所有的TEXTAREA都会被替换成0.015。
> 这一过程被 称为编译时替换（compile-time substitution）
> =>:#define name value
- const限定符
> 限定一个变量只读：const int mouth=12;
- printf()
> printf()与scanf()函数又称为输入输出函数，I/O函数
```
  转换说明            输出
  %A/%a             浮点数，十六进制和p计数法
  %c                单个字符
  %d                有符号十进制整数
  %e/%E             浮点数，e计数法
  %f                浮点数，十进制计数法
  %g/%G             根据值的不同，自动选择%f或%e,%e格式用于指数小于-4或者大于或等于精度时
  %i                有符号十进制整数（==%d）
  %o                无符号八进制整数
  %p                指针
  %s                字符串
  %u                无符号十进制整数
  %x/%X             无符号十六进制整数
  %%                打印一个百分号
```
- printf()的转换说明修饰符
> 在%和转换字符之间插入修饰符可修饰基本的转换说明
> 详情请见4.4.3
> 转换说明：%m.nf m指定字段宽度,n指定小数点精度
- 转换说明的意义
> 转换说明把二进制格式存储在计算机中的值转换成一系列字符（字符串）。以便于显示，例如数字76在计算机内部的存储格式
> 是二进制01001100，%d转换说明将其转换成字符7和6，并显示为76，转换说明并不是替换，而是翻译
- printf()函数的返回值
> printf()函数也有一个返回值，它返回打印字符的个数。如果有输出错误，printf()则返回一个负值
- scanf()函数
> C的多个输入函数之一，可以读取不同格式的数据，scanf()把输入的字符串转换成整数，浮点数，字符或字符串，而printf()正好相反，
> 把整数、浮点数、字符、字符串转换成显示在屏幕上的文本，printf()和scanf()函数的区别主要在参数列表
> printf()函数使用常量、变量、表达式，而scanf()函数使用指向变量的指针
> 1：如果scanf()读取基本类型的变量的值，在变量名前加一个&
> 2：如果用scanf()把字符串读入字符数组中，不要使用&
- 其他输入函数
> getchar(),fgets()
- printf()和scanf()的*修饰符
> 如果你不想预先指定字段宽度，希望通过程序来指定，那么可以用*修 
> 饰符代替字段宽度。但还是要用一个参数告诉函数，字段宽度应该是多少。 
> 也就是说，如果转换说明是%*d，那么参数列表中应包含*和 d对应的值。这 
> 个技巧也可用于浮点值指定精度和字段宽度
- 关键概念
- 什么是空白
> 空白包括空格、制表符和换行符。C 语言使用空白分隔记号。
> scanf()使用空白分隔连续的输入项

### chapter5: 运算符，表达式和语句
- 基本运算符
> = + - * /  虽然C没有指数运算符，但是C的标准数学库提供了pow()函数用于指数运算
> 一般来说，变量是可修改的左值，表达式是右值
- sizeof运算符和size_t类型
> sizeof以字节为单位返回运算对象大小，通常返回size_t类型(这是一个无符号整数类型)
> size_t不是新类型，是c语言定义的标准类型typedef double real; real deal,此时deal可以被判断为double类型
> size_t使用C99新增的%zd转换说明 -- 如果编译器不支持%zd，请将其改成%u或%lu
- 负数的求模
> C99规定“趋零截断”，如果第一个运算对象是正数，求模结果为正数，如果第一个运算对象为负数，则求模结果也为负数
> 11/5=2 11%5=1   11/-5=-2  11%-5=1  -11/5=-2 -11%5=-1 -11/-5=2 -11%-5=-1
> 事实上标准规定:无论何种情况，只要a,b都是整数值，便可通过a-(a/b)*b来计算a%b:
> -11%5=>-11-(-11/5)*5=-11-(-2)*5=-11+10=-1
- 自增自减运算符++ --
> ++/--出现在前面的叫做前缀模式，出现在后面的叫后缀模式
> 前缀模式先自增后运算，后缀模式先运算后递增
> 如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符
> 如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。
- 总结C的一些运算符
```
1:赋值运算符：= 将右边的值赋给左边的变量
2：算数运算符 + - * / % ++ --
3:其他运算符：sizeof 获得其右侧运算对象的大小
```
### chapter6: C控制语句：循环
> for while do while 
- 真、假
> 对c语言来说1==true 0==false,即表达式的值为1为真，表达式的值为0为假
> 一般而言，所有非0的值被视作真，只有0被视作假
- _Bool类型
> 只存储两个值，真（1）/假（0），如果把其他非零数值赋给_Bool类型的变量，该变量会被设置为1
> 这反映了C把所有的非零值都视为真
- 优先级与关系运算符
> 关系运算符的优先级比算数运算符（包括+、-）低，比赋值运算符高，
> 与其他大多数运算符一样，关系运算符的结合律也是从左往右，关系运算符之间有两种不同的优先级组
> 高优先级组：< <= > >= 低优先级组 ！=  ==
- 逗号运算符
> 逗号运算符把两个表达式连接成一个表达式，并保证最左边的表达式最先求值
> while循环： 初始化 while(测试){更新}  for(初始化;测试;更新)   初始化  do{更新 }while(测试)
- 字符数组
> 可以把字符串储存在char类型的数组中（一般而言，char类型数组的所有元素都储存char类型的值）。
> 如果char类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成了一个字符串

### chapter7: C控制语句：分支和跳转
- getchar()与putchar()
> getchar()函数不带任何参数，它从输入队列中返回下一个字符：ch=getchar()
> ==>scanf("%c",&ch);
> putchar()函数打印他的参数：putchar(ch):把ch的值作为字符打印出来
> ==》printf("%c",ch);
> 注意 getchar()和 putchar()不需要转换说明,因为它们只处理字符
- 逻辑运算符
> && 或 || 与  ！ 非  iso646.h将这些符号使用关键字替代  and or not
- 优先级
> !运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相 
> 同，只比圆括号的优先级低。&&运算符的优先级比||运算符高，但是两者的 
> 优先级都比关系运算符低，比赋值运算符高。因此，表达式a >b && b > c || 
> b > d相当于((a > b) && (b > c)) || (b > d)。
- 求值顺序(序列点与副作用)
> 除了两个运算符共享一个运算对象的情况外(3*x+2，其中x属于这个情况)，C 通常不保证先对复杂表达式中哪部分求值
> 但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右。&&和||运算符都是序列点，
> 所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。
> 而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值（短路）。
> 例如：while ( x++ < 10 && x + y < 20)    
> =》实际上，&&是一个序列点，这保证了在对&&右侧的表达式求值之前，已经递增了x。
- 范围
> 求90-100之间的判断：if (range >= 90 && range <= 100)，千万不要写成：
> (90<=x<=100),编译器这样理解：(90<=x)<=100，原因是逻辑运算符求值是从左往右：
> 导致前面的结果是一个布尔值（0/1）,即0<=100或者1<=100，这是一个恒为真的判断
- 条件运算符
> expression? expression1:expression2
- continue
> continue还可用作占位符,与其循环中不写任何内容，不如协商continue
> 通常情况下，把if的测试条件的关系反过来便可避免使用continue
- break
> 通常用来推出循环和选择
- 多重选择：switch/break
> 他是if elseif else的变体，用于多重选择
> break语句可用于循环和switch语句，但是continue只能用于循环中，如果switch在一个循环中
> 则可以使用continue,C语言中的switch圆括号中的值必须是一个整数值，包括char类型 (整形表达式)
- 多重标签
> 在switch中可以使用多个case,省略其中的break表示顺序执行,执行其中一个之后无需判断另一个,直接执行(因为其中没有break语句)
- switch一般注解
> 程序根据expression的值跳转至相应的case标签处。然后，执行剩下的所有语句，除非执行到break语句进行重定向。
> expression和case标签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。
> 如果没有case标签与expression的值匹配，控制则转至标有default的语句（如果 有的话）；
> 否则，将转至执行紧跟在switch语句后面的语句。
- goto
> goto part2;
> part2:printf("this is goto statement\n")

### chapter8: 字符输入/输出和输入验证
- 单字符IO:getchar()和putchar()
> 每次只处理一个字符，
- 缓冲输入、无缓冲输入
> 把若干个字符作为一个块输入要提高效率，无缓冲输入在游戏等立刻执行情况下有有用武之地
> 缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中
> 行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区
- 文件结尾
> 通常有两种方法，一种是在文件结尾标记特殊字符（例如ctrl+z）,另外一种是计算文件的大小，当达到指定大小时，
> 就算达到了文件末尾，在c语言中，无论哪种情况，当使用getchar()读取文件监测到结尾时都将返回EOF(End OF File)
> scanf()函数监测到文件结尾时也返回EOF
- 重定向输入（<）
> 假设已经编译了echo_eof.c  程序，并把可执行版本放入一个名为echo_eof（或者在Windows系统中名为echo_eof.exe）的文件中。
> 运行该程 序，输入可执行文件名:echo_eof(windows为echo_eof.exe),该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入。
> 现在，假设你要用该程序处理名为words的文本文件:echo_eof < words (windows为echo_eof.exe<word)
- gcc编译源文件
> gcc echo.c --如果没有指定文件名称，则生成a.out(linux) 或 a.exe(windows)。
> gcc 源文件名 -o 目标文件名  ：gcc hello.c -o target/hello会在 target 目录下生成 hello.exe 文件(Linux 系统生成 hello 可执行文件)
- 重定向输出（>）
> 现在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。
> 然后，输入以下命令并开始输入:echo_eof>mywords 
> 通常会擦除该文件的内容，然后替换新的内容,
> 记住在每行的末尾单击Enter键，这样才能把缓冲区的内容发送给程序
- 组合重定向
> 现在，假设你希望制作一份mywords文件的副本，并命名为savewords。
> 只需输入以下命令即可:echo_eof < mywords > savewords
> 下面的命令也起作用，因为命令与重定向运算符的顺序无关：
> echo_eof > savewords < mywords
- 关于重定向运算符
> 重定向运算符连接一个可执行程序（包括标准操作系统命令）和一个数据文件，
> 不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序。
> 使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件
- 追加运算符（>> 运算符）
> 该运算符可以把数据添加到现有文件的末尾,而 | 运算符能把一个文件的输出连接到另一个文件的输入
- 小结
> prog>file:将输出重定向至文件， prog<file:将输入重定向至文件
> prog>file1<file2 prog<file2>file1  这两种形式都是把file2作为输入、file1作为输出
- 输入验证
> 简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值。
> 使用转换说明（如%d或%f）限制了可接受输入的字符类型，而getchar()和使用%c的scanf()接受所有的字符。
- 关键概念
> C程序把输入作为传入的字节流。getchar()函数把每个字符解释成一个字符编码。
> scanf()函数以同样的方式看待输入，但是根据转换说明，它可以把字符输入转换成数值。
> 许多操作系统都提供重定向，允许用文件代替键盘输入，用文件代替显示器输出。

```
  许多程序使用 getchar()逐字符读取输入。通常，系统使用行缓冲输入，
  即当用户按下 Enter 键后输入才被传送给程序。按下Enter键也传送了一个换
  行符，编程时要注意处理这个换行符。ANSI C把缓冲输入作为标准
  
  通过标准I/O包中的一系列函数，以统一的方式处理不同系统中的不同
  文件形式，是C语言的特性之一。getchar()和  scanf()函数也属于这一系列。
  当检测到文件结尾时，这两个函数都返回  EOF（被定义在stdio.h头文件中）

  混合使用 getchar()和 scanf()时，如果在调用 getchar()之前，scanf()在输
  入行留下一个换行符，会导致一些问题。不过，意识到这个问题就可以在程
  序中妥善处理。
```
### chapter9: 函数
- 递归
> 最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。
> 这种形式的递归被称为尾递归（tail recursion），因为递归调用在函数的末尾。
> 尾递归是最简单的递归形式，因为它相当于循环
> 递归如果循环次数过多则会创建大量的变量（呈指数倍增长）
- 编译多源文件代码程序
> unix: cc file1.c file2.c 生成a.out文件，同时还生成file1.o file2.o目标文件
> 如果只改变file1.c 则合并：cc file1.c file2.o
> linux:gcc file1.c fil2.c   gcc file1.c file2.o
> windows:类似linux
- 查找地址：&运算符
- 间接运算符*
> *间接运算符用于找寻存贮在内存地址上的值，也叫解应用运算符
> 变量名和内存地址一一对应，当编译后就不存在变量名了，只有内存地址，name表示地址上的值，&name表示内存地址，它只能赋值给指针变量
> var=*pr 找出指针变量指向的值（pr实际上市一个内存地址（指针），存储的是（指向的是）某个变量的内存地址，*pr实际上就是对其指向的内存地址求值）
- 指针
> 指向存储类型变量地址
> 假设一个指针的变量名为pr,则 pr=&name (把name变量的内存地址赋值给pr)
> 语句 pr=&name, val=*pr ==>val=name,由此可见,使用地址和间接运算符可以间接完成
> 赋值语句
- 小结：与指针相关的运算符
> 地址运算符&：给出变量的地址，间接运算符*：给出存储在指针指向地址上的值
- 指针的声明
> 声明指针时必须指定指针所指向的变量的类型，因为不同的类型占用不同的存储空间，另外，占用相同存储空间的不同类型的数据
> 他们的存储方式可能也大相径庭
> int *pi  char *ch  float *f,*g 
- 关于int *pc
> 类型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量是一个指针 int *pc,声明的意思是pc是一个指针
> *pc是int类型，pc是指向int类型变量的指针，所以说*是解应用运算符，pc的值是一个地址，大多数系统内部，指针由无符号整数表示，
> 但是指针并不是整数类型，它是一种新类型，ANSI C 专门为其提供了%p格式的转换说明
- 变量：名称、地址、值
> 编写程序时，可以认为变量有两个属性，名称和值，计算机编译和加载程序后，认为变量也有两个属性，地址和值，地址就是变量在计算机内部的值
> 在许多语言中，地址都归计算机内部管理，对程序员隐藏，然而在c中，可以通过&运算符访问地址，通过*运算符获得地址上的值，
> 例如&ban表示变量ban的地址，使用名称获得的是变量的值，例如：printf("%d\n",ban)打印ban的值，使用*运算符即可获得存储在地址上的值，如果path=&ban
> 则*path表示存储在&ban地址上的值
- 概括
> 普通变量把值作为基本量，把地址作为通过&运算符获得的派生量，指针变量把地址作为基本量，把值作为通过*运算符获得的派生量

### chapter10:数组和指针
- 数组
> 对于自动存储类别的数组（在函数内部声明的，不带static的），如果不初始化数组，数组元素和未初始化的普通变量一样，其中存储的都是垃圾值，
> 蜀国初始化部分数组，剩余的元素就会被初始化为0,如果初始化项多于数组个数，则会报错，其实可以省略方括号中的数组个数，让编译器自动匹配数组大小
> 根据初始化时的数据项数目
- 指定初始化器
> 可以初始化指定的数组元素，例如初始化最后一个元素
> int arr[6]=[0,0,0,0,0,216],现在可以这样：int arr[6]={[5]=216}
- 数组边界
> 编译器不会报错，关于数组的边界需要程序员自己注意（编译器不检查，程序运行的更快）
> 数组的大小最好使用符号常量表示，这样做能确保整个程序中的数组大小始终一致
- 变长数组
> C99允许这么定义数组 int m=5 int arrs[m];此时arrs称为变长数组，它有一些限制，比如声明的时候不能初始化
- 多维数组
> float[5][12]
> 初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，
> 初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。
> 后面没有值初始化的元素被统一初始化为0
- 其他多维数组
> int box[10][20][30] 
> 可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表
> 例如，把上面声明的三维数组box想象成由10个二维数组（每个二维数组都是20行30列）堆叠起来。
> 还有一种理解box的方法是，把box看作数组的数组。也就是说，box内 含10个元素，
> 每个元素是内含20个元素的数组，这20个数组元素中的每个元素是内含30个元素的数组。
> 或者，可以简单地根据所需的下标值去理解数组
> 通常，处理三维数组要使用3重嵌套循环，处理四维数组要使用4重嵌套循环。对于其他多维数组，以此类推
- 指针和数组
> 指针再某种程度上把程序员想要表达的指令以更接近机器的方式表达，数组表示法其实是在变相的使用指针
> 例如：数组名是数组首元素的地址=》arrs==&arrs[0] (&是地址运算符)，他们都是常量，在运行过程中不会改变
> 可以把他们赋值给指针变量，然后可以修改指针变量的值
```
  指针的值是它所指向对象的地址，地址的表示方式依赖于计算机内部的硬件，许多计算机都是按字节编址
  意思是内存中的每个字节都按照顺序编号，这里，一个较大的对象的地址（如double类型的变量）通常是该对象第一个字节的地址
  在指针前面加上*运算符可以得到该指针所指向对象的值
  指针加1，只针对额值递增他所指向类型的大小（以字节为单位）
  下面的等式体现了c语言的灵活性：
    dates+2==&date[2] //相同的地址
    *(dates+2)=dates[2] //相同的值
  以上关系表明数组和指针关系十分密切，可以使用指针标识数组的元素和获取元素的值，从本质上看，同一个对象有两种表示法
  实际上C语言标准在描述数组表示法时确实借助了指针，也就是说定义arr[n]的意思是*(arr+n),可以认为*(arr+n)的意思是：
  到内存的arr位置，然后异动n个单元，检索存储在那里的值
  *(date3+2)==》dates的第三个元素
  *dates+2 dates的第一个元素的值+2  
```
- 函数、数组和指针
> 编写一个处理数组的函数，返回数组中所有元素之和：
> total=sum(members);//也许你会这样调用函数
```
  那么，该函数的原型是什么？记住，数组名是该数组首元素的地址，所以members实际上是一个存储int类型值的地址
  应该把它赋值给指针形式参数，即参数应该是一个指向int的指针
    int sum(int *arr);//对应的函数原型
  但是上面sum(members)只是获得了,数组首元素的地址，并未包含数组元素个数信息
    int sum(int *arr){
      int i;int total=0;
      for(i=0;i<10;i++){
        total+=arr[i];//这里arr[i]与*(arr+i)相同
      }
    }  
  既然可以使用指针表示数组名，也可以使用数组名表示指针：
  int sum(int *arr,int m)
  上方的形参表示数组的地址和数据类型，第二个参数表示原数组个数  
  在函数的形参中表示中，可以在函数原型表示上，使用int arr[]代替int *arr
  int sum(int[] arr,int m)//数组名是该数组首元素的地址，形参是一个与之匹配的指针或数组
  下面代码等价：
      int sum(int arr[],int m){}//arr是首位地址，可以赋给指针变量
      int sum(int *arr,int m){}//arr是一个指针
  
```
- 使用指针形参
> 函数处理数组，必须要知道何时开始何时结束，sum()函数使用一个指针表示数组开始，一个整数表示待处理数组个数
> 这并不是传递信息的唯一办法，还有一种方法是传递两个指针，第一个指针指明数组的开始处，第二个指针指明数组的结束处
- 指针表示法和数组表示法
> 处理数组的函数实际上使用指针作为参数，但是在编写这样的函数时，可以选择使用数组表示法还是指针表示法，
> 对于c语言，arr[i]和*(arr+i)这两个表达式都是等价的，无论arr是数组名还是指针变量，这两个表达式都没问题，但是只有是指针
> 变量时，才可以使用arr++这类表达式

- 指针操作
> 指针变量有8种基本的操作：
> 把一个地址赋值给指针  递增指针 递减指针 恢复为初始值 一个指针减去另一个指针 一个指针减去一个整数 解引用指针 获得指针地址
```
    赋值：可以把地址赋值给指针，例如使用数组名，带地址运算符&的变量名，另一个指针进行赋值，注意地址应该和指针类型兼容，不能把double类型的地址赋值给int类型的指针
    解引用：*运算符给出指针指向地址上存储的值，地址是内存中连续排列的大小单元，一般以字节为单位
    取址：和所有变量一样，指针变量也有自己的地址和值，对指针而言，&运算符给出指针本身的地址，指针变量本身表示该地址上的值
    指针与整数相加：整数与类型大小相乘，然后同指针地址相加：pt1+4==>urn[4],如果相加结果超出指针指向数组的范围，则计算结果为未定义的
    指针递增：递增指向数组元素的指针可以让指针指向数组的下一位元素相当于指针移动了该数据类型的字节数
    比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同的类型
    解引用未初始化的指针会有问题；int *pt1l  *pt1=5 会出问题，后面将5赋值给pt1指向的位置，但是pt1没有被初始化
        切记；创建一个指针变量时，系统只分配了存储指针本身的内存，并未分配存储数据的内存,因此在使用指针前，必须使用已分配的地址初始化它，
        例如可以使用一个现有的变量的地址初始化它（使用带指针形参的函数时，就属于这种情况）
            假设：int um[3];int *pt1,*pt2;//未初始化的指针
            有效：pt1++;pt2=pt1+2;pt2=um+1;
            无效：um++;pt2=pt2+pt1;pt2=urm+pt1
    基于这些有效的操作，c创建了数组指针，函数指针，指向指针的指针数组，指向函数的指针数组
    指针的第一个用法是在函数间传递信息（被调函数中改变主调函数的变量）
    指针的第二个用法是用在处理数组的函数中
```
- 保护数组中的数据
> 编写一个处理int类型的函数时，要选择是传递int类型的值还是传递指向int的指针，通常都是直接传递数值，只有在需要改变该数值的时候才会传递指针，数组别无选择
> 只能传递指针，因为这样做效率高，如果一个函数按值传递数组，则必须分配足够的空间来存储原数组的副本，然后把原数组的数据拷贝到新的数组中
> 如果把这个数组的地址传递给函数，让函数处理原数组则会效率更高，传递地址会导致一些问题，c通常都按照值传递数据，因为这样做可以保证数据的完整性，但是处理数组的函数
> 通常都会使用原始的数据,
- 对形式参数使用const
> 如果函数的意图不是修改数组中的内容，那么在函数的原型和定义中声明形式参数应该使用const,如果在函数中不小心使用指针更改了原始数据，编译器会捕获这个错误并生成错误信息
> 一般而言，如果编写的函数需要改变原始数组，在声明数组行参时不使用const,如果不需要改变，则应该使用const
- const的其他内容
> 可以创建const变量，const数组，const指针，和指向const的指针
> 无论是使用指针表示法还是使用数组表示法，都不允许pd修改它所指向的数据
```
  关于指针赋值和const需要注意的一些地方：
    1：把const的数据或非const数据的地址初始化为指向const的指针或为其赋值是合法的
      double rate[]={12.1,32,33.3};
      const double rates2[]={12.33,34.55,3445.33};
      const double *pc=rate;//有效
      pc=rates2;//有效
      pc=&rate[2];//有效
    2：只能把非const数据的地址赋值给普通指针
      double * ps2=rate;//有效
      ps2=rates2;//无效
      ps2=rate[2];//有效
    这个规则十分合理，否则通过指针就能改变const数组中的数据了
    C语言规定，使用非const标识符（如函数的形参）去修改const数据，如rates2,导致的结果是未定义的
    const可以声明并初始化一个不能指向别处的指针，关键是const的位置
    double rass[5]={12,12.33,23,44,4,6}
    double *const pcs=rass;//pcs指向数组的开始位置
    pcs=&rass[2];//不允许，因为该指针不能指向别处
    *pc=22.88;//ok，更改rass[0]的值
    可以用这种指针修改它所指向的值，但是他只能指向初始化的地址
    还可以在创建指针的时候使用两次const,该指针既不能改变它所指向的地址，也不能修改指向地址上的值
    double arrays[2]={12,23.44}
    const double *const pss=arrays;
    pss=&arrays[2];//不允许
    *pss=22.44;//不允许    
```
- 指针和多维数组
> 指针和多维数组有什么关系，处理多维数组的函数要用到指针
```
  * * * *
  * * * *
  假设有如下声明：int zippo[4][2];//内含int数组的数组
  然后数组的名称zippo是该数组首元素的地址，在本例中，zippo首元素是一个内涵两个int值的数组,所以zippo是这个内涵两个int值的数组的地址
  我们从指针进一步分析：
    因为zippo是数组首元素的地址，在本例中，所以zippo的值和&zippo[0]的值相同，而zippo[0]本身是一个内含两个int值的数组
    所以zippo[0]的值是和他内部的首元素（一个int值）的地址相同，简而言之：zippo是一个占用两个int大小的数组的地址，zippo[0]是一个占用一个int大小的整数的地址
    由于这个整数的地址和内含两个整数的数组的地址都开始于同一位置，所以zippo和zippo[0]的值相同
  
  给指针或地址+1，会增加对应类型大小的数值，在这方面zippo和zippo[0]不同，zippo的但愿是两个整形的数组，而zippo[0]的单元是int类型整数，所以zippo+1于zippo[0]+1的值不同，
  
  解引用一个指针（在指针前面使用*运算符）或在数组名后面使用带下标的[]运算，得到引用对象代表队额值，因为zippo[0]是该数组的首元素
  （zipp0[0][0]）的地址，所以*zippo[0]，代表存储在zippo[0][0]地址上的值，于此类似，*zippo代表该数组首元素（zippo[0]）的值，但是因为
  zippo[0]本身是一个int类型值的地址，该值的地址是：&zippo[0][0],所以*zippo==&zippo[0][0],==>**zippo==*&zippo[0][0]==zippo[0][0]
  由上可以得知，**zippo==int值，所以zippo是地址的地址，需要解引用两次才能得到原始int值
    地址的地址或者指针的指针就是双重间接的例子，详情见例子zippo1.c
```
- 数组指针理解
> 在我们的系统中，int是4字节，zippo[0]指向一个4字节的数据对象，zippo[0]+1,其值加4
> 数组名zippo是一个内含2个int类型值的数组的地址，所以zippo指向一个8字节的数据对象，zippo+1,
> 它所指向的地址加8个字节
- 取值
> zippo[0]和*zippo完全相同，然后对二维数组名解引用两次，得到存储在数组中的值，使用两个间接运算符* 或者使用两队方括号，或者一个*和【】都可以
- 指向多维数组的指针
> 如何编写一个指针变量pz指向一个二维数组如zippo,在编写处理类似zippo这样的二维数组的时候会用到这样的指针，
> 把指针声明为执向int的类型还不够，因为指向int的只能和zippo[0]的相匹配，说明该指针指向一个int类型的值，但是zippo是他的首元素地址，该元素是一个包含
> 两个int类型的一维数组，因此pz必须指向一个包含两个int类型值的数组，而不是指向一个int类型值，其声明如下：
```
  int (*pz)[2]; pz指向一个内含两个int类型值的数组
  以上代码将pz声明为指向一个数组的指针，该数组内含两个int类型的值，为什么使用（），因为【】优先级高于*
  考虑如下声明：
    int *ps[2];//ps是一个内含两个指针元素的数组，每个元素都指向int的指针
      由于【】优先级高于*，先于ps结合，所以ps成为一个内含两个元素的数组，然后*表示ps数组内含两个指针 ，最后int表示ps数组中的指针都指向int类型的值
      前方的则表示：*先于pz结合，因此声明的是一个指向数组（内含两个int类型的值）的指针
```
- 指针的兼容性
> 指针之间的赋值比数值类型值之间的赋值要严格的多，数据之间可以是使用类型转换，把int赋值给double类型变量
> 但是指针之间是不可以这样做的：如下：
```
  int n=5;
  double x;
  int *px=&n;
  double  *db=&x;
  x=n;//隐式类型转换
  db=px;//编译器错误
  更复杂的类型也是如此：
  int *pt;
  int(*pa)[3];
  int arr1[2][3];
  int arr2[3][2];
  int **p2;//一个指向指针的指针
  有如下语句
  pt=&arr1[0][0];//都是指向int的指针
  pt=arr1[0];//都是指向int的指针
  pt=arr1;//无效  pt 指向一个 int类型值，而ar1指向一个内含3和int类型元素的数组
  pa=arr1;//都是指向内含三个int值数组的指针
  pa=arr2;//无效 pa指向一个内含2个int类型元素的数组 arr2指向内含3个int类型元素的数组
  p2=&pt  ;//指针的指针
  *p2=arr2[0];都是指向int的指针
  p2=arr2;//无效 p2指向的指针指向int,arr2指向的指针是一个数组，类型不兼容
```
- 多重解引用让人费解
> 详情请见练习dereference.c
- C const和C++ const
```
  C和C++中const的用法很相似，但是并不完全相同。区别之一是，
  C++允许在声明数组大小时使用const整数，而C却不允许。区别之二是，
  C++的指针赋值检查更严格：
  const int y;
  const int * p2 = &y;
  int * p1;
  p1 = p2; // C++中不允许这样做，但是C可能只给出警告
  C++不允许把const指针赋给非const指针。而C则允许这样做，但是如果
  通过p1更改y，其行为是未定义的。  
```
- 函数和多维数组
> 要编写处理二维数组的函数，先要正确理解指针才能写出声明函数的形参
- 多维数组指针表示法
> 一般而言，声明一个指向N维数组的指针时，只能省略最左边的一堆方括号中的值：
> int sum4(int arr[][2][3][4]),因为第一队方括号只用来表明这是一个指针，而其他方括号用来
> 描述指针所指向数据对象的类型，下面的声明与上面的等价：
> int sum5(int (*arr)[2][3][4]),arr时一个指针，指向一个2*3*4的int数组
- 变长数组(VLA==>variable length array)
> C规定，数组的维数必须是常量，不能用变量代替cols, C99新增了变长数组，允许使用变量表示数组的维度
> int x=5;int y=4; int array[x][y]
```
  变长数组有一些限制：变长数组必须是自动存储类型，这意味着无论再函数中声明还是作为函数形参使用
  都不能使用static/extern存储类别说明符，而且不能在声明中初始化他们
  注意，变长数组不能改变大小，这里的变指的是创建数组时可以使用变量指定数组的维度，一旦创建了变长数组，
  他的大小则保持不变：
  int sums(int rows,int cols,int arr[rows][cols])//注意参数顺序，因为存在先后关系，不能先声明arr
  让然也可以省略形参名==》int sums(int,int,int arr[*][*]);//省略维度形参名，使用星号代替
  在函数定义的形参列表中声明的变长数组并未实际创建数组，和传统的语法类似，变长数组名实际上就是一个指针
  这说明带变长数组形参的函数实际上是在原数组中处理数组，因此可以修改传入的数组
  int thing [10][6]
  toset(10,6,thing)==>这里的thing指针就是传递函数形参的指针，可以根须函数形参来修改原数组
  int toset(int,int,int arr[*][*]) arr表示指向thing[0]的指针（thing是一个指针，指向长度为10的数组（内含6个int值））
  因为ar和thing都是指向thing[0]的指针，ar[0][0]与thing[0][0]访问的数据位置相同
```
- const和数组大小
> C99/C11 标准允许在声明变长数组时使用 const 变量。
> 所以该数组的定义必须是声明在块中的自动存储类别数组。
> 变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大 小。
> 普通 C数组都是静态内存分配，即在编译时确定数组的大小。
> 由于数组 大小是常量，所以编译器在编译时就知道了。
- 复合字面量
> 类似int字面量 4 ，double字面量2.33，char字面量'Y',字符串字面量“element”
> 数组也有字面量，普通声明数组 int div[2]={2,3},字面量表示为：（int[2]）{2,3}
> 其中：去掉声明中的数组名，留下的int[2]就是复合字面量的类型名
```
  初始化有数组名的数组时可以省略数组的大小，复合字面量也可以省略数组的大小，编译器会自动计算数组当前元素的个数
  int arr[]={2,4}
  (int[]){2.4}
  以为复合字面量是匿名的，所有不能先创建然后使用它，必须创建的同事使用它：
  int * pt1;
  pt1=(int[]){2,3}
  与有数组名的数组类似，复合字面量的类型名称也代表首元素的地址，所以可以把他赋值给
  指向int的指针没然后使用该指针，例如*pt1=2,pt1[1]=3
  还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数
  例如： total=sum((int[]){2,3});这样使用的好处是：把信息传入函数前不必创建数组
  还可以类似用于二维数组或多维数组: int(*pt2)[4],pt2=(int[2][4]{{1,2,3,4},{2,3,4,5}})
```
- 关键概念
```
  1:C把数组名解释为该数组首元素的地址，换言之，数组名与指向该数组首元素的指针等价，概括的说，数组与指针的关系十分密切
  如果ar是一个数组，那么ar[i]与*(ar+1)等价
  2:对于C语言而言，不能把整个数组作为参数传递给函数，但是可以传递数组的地址  ，然后函数可以使用传入的地址操控原始数组，如果
  没有修改原始数组的意图，则函数的形参应该使用const关键字修饰，在被调函数中可以使用数组表示法或者指针表示法，无论使用哪一种表示法，实际上使用的都是指针变量
  3:指针加上一个整数或者递增指针，指针的值所指向的对象的大小为单位改变，也就是说，如果pd指向一个数组的8字节都变了类型的值那么pd加一意味着，其值加上8，以便指向该数组的下一个元素
  4：C语言传递多维数组的方式是把数组名（即数组的地址）传递给类型匹配的指针形参，声明这样的指针形参需要指定所有的数组维度，除了第一个维度
    传递的第一个维度通常作为函数的第二个参数： int sum(int arr[][12],int rows)==>int sum(int (*arr)[12],int rows)
  5:变长数组 int sums(int rows,int cols,int arr[rows][cols])  
```

### chapter11: 字符串和字符串函数
- 表示字符串和字符串I/O
> 字符串是以空字符（\0）结尾的char类型数组，由于字符串十分常用，所以C提供了许多专门用于处理字符串的函数
```
  1:字符串字面量：用双引号括起来的，也叫字符串常量，双引号中的而字符和编译器自动加入末尾的\0字符，都作为字符串存储在内存中
    如果字符串字面量之间没有间隔，或者用空白字符分割，C会视其为串联起来的字符串字面量
    如果要在字符串内部使用双引号，则需要在前面添加一个反斜杠
      “\"hasdasdada\"” ==>"hasdasdada"
    字符串常量属于静态存储类别（static storage class）,这说明如果在函数中使用字符串字面量，该字符串只会被存储一次 
    在整个程序的生命期内存在，用双引号括起来的内容被视为指向该字符串存储位置的指针
    类似于数组名作为指向数组位置的指针
  2：字符串数组和初始化
    定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足够空间的数组储存字符串
    const char m1[10]={'s','p','r','i','n','g','\0','','',''}
    注意最后的空字符。没有这个空字符，这就不是一个字符串，而是一个字符数组,
    在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为了容纳空字符）
    所有未被使用的元素都被自动初始化为0（这里的0指的是char形式的空字符，不是数字字符0）
    const char at[]="xahaduahsdi asdsd.";让编译器确定字符数组大小
    char car[10]="Tata";==>car=&car[0] *car='T' *(car+1)='a'
  3:指针表示法创建字符串  
```
- 指针和字符串
> 字符串的绝大部分操作是通过指针完成的
- 字符串输入
> 如果想把一个字符串读入程序，首先需要预留存储该字符串的空间，然后用输入函数获取该字符串
- gets()函数
> 读取字符串时，scanf()和转换说明%s只能读取一个单词，gets()用于整行输入读取，知道遇到换行符，然后丢弃换行符，存储其余字符，并在末尾加上
> 空字符使其成为一个字符串，经常和puts函数配合使用（用于显示字符串，并在末尾加上换行符）,过去，有些人通过系统编程，利用gets()插入和运行一些破坏系统安全的代码。
- gets()函数的替代品
> 通常fgets()替代get(),gets_s()也可以替代gets(),
```
  1:fgets()与fputs()函数：
    fgets函数的第二个参数表示读入字符的最大数量，如果为n,表示最多读取n-1个，同时加上一个换行符，专门用于处理文件输入，
    第三个参数指明要读入的文件，如果从键盘输入数据则以stdin(标准输入)作为参数，该标识符定义在stdio.h中
    fputs函数用于输出字符，第二个参数指明他要写入的文件，如果是显示在计算机屏幕上，则使用stdout(标准输出)作为参数
    fputs(words,stdout);fputs()函数返回指向 char的指针。如果一切进行顺利，该函数返回的地
    址与传入的第 1 个参数相同，但是，如果函数读到文件结尾，它将返回一个
    特殊的指针：空指针（null pointer）。该指针保证不会指向有效的数据，所
    以可用于标识这种特殊情况。在代码中，可以用数字0来代替，不过在C语
    言中用宏NULL来代替更常见（如果在读入数据时出现某些错误，该函数也
    返回NULL） 
```
- 空字符和空指针
> 空字符（'\0'）适用于标记c字符串末尾的字符，其对应的字符编码是0,其他字符的编码不可能是0，所以不可能是字符串的一部分
> 空指针有一个值，该值不会与任何数据的有效地址对应
> 空字符是整数类型，而空指针是指针类型。两者有时容易混淆的原因 是：
> 它们都可以用数值0来表示。但是，从概念上看，两者是不同类型的0。 
> 另外，空字符是一个字符，占1字节；而空指针是一个地址，通常占4字节。
- gets_s()函数
> C11新增的gets_s()函数（可选）和fgets()类似，用一个参数限制读入的字符数。
> 假设把程序清单11.9中的fgets()换成gets_s()，其他内容不变，
> 那么下面的代码将把一行输入中的前9个字符读入words数组中，假设末尾有换行符
```
  gets_s(words, STLEN);
  gets_s()与fgets()的区别如下。
  gets_s()只从标准输入中读取数据，所以不需要第3个参数。
  如果gets_s()读到换行符，会丢弃它而不是储存它。
    如果gets_s()读到最大字符数都没有读到换行符，会执行以下几步。首
    先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直至读到换
    行符或文件结尾，然后返回空指针。接着，调用依赖实现的“处理函数”（或
    你选择的其他函数），可能会中止或退出程序
  只要输入行未超过最大字符数，gets_s()和gets()几乎一
  样，完全可以用gets_s()替换gets()。
  
  我们来比较一下 gets()、fgets()和 gets_s()的适用性。如果目标存储区装
  得下输入行，3 个函数都没问题。但是fgets()会保留输入末尾的换行符作为
  字符串的一部分，要编写额外的代码将其替换成空字符
  
  如果输入行太长会怎样？使用gets()不安全，它会擦写现有数据，存在
  安全隐患。gets_s()函数很安全，但是，如果并不希望程序中止或退出，就
  要知道如何编写特殊的“处理函数”。另外，如果打算让程序继续运行，
  gets_s()会丢弃该输入行的其余字符，无论你是否需要。由此可见，当输入
  太长，超过数组可容纳的字符数时，fgets()函数最容易使用，而且可以选择
  不同的处理方式。如果要让程序继续使用输入行中超出的字符，可以参考程
  序清单fget2中的处理方法。如果想丢弃输入行的超出字符，可以参考程序清
  单fgets3中的处理方法。
  所以，当输入与预期不符时，gets_s()完全没有fgets()函数方便、灵活。
  也许这也是gets_s()只作为C库的可选扩展的原因之一。鉴于此，fgets()通常
  是处理类似情况的最佳选择
  
```
- scanf()函数
> scanf函数更像是“获取单词函数”，而不是获取字符串函数,以第一个非空白字符作为字符串的开始，以下一个空白符作为字符串的结束,
> scanf返回一个整数值，等于scanf成功读取的项数或者文件结尾EOF
```
_：表示空格字符
  输入语句                  原输入序列           name中的内容        剩余输入序列
  scanf("%s",name)      Fleebert_Hup         Fleebert           _Hup
  scanf("%5s",name)     Fleebert_Hup         Fleeb              ert_Hup
  scanf("%5s",name)     Ann_Ular             Ann                _Ular
  scanf()和gets()类似，也存在一些潜在的缺点，如果输入行的内容过长，scanf也会导致数据溢出，不过在%s准换说明中使用字段宽度可以防止溢出
```
- 字符串输出
> C有三个标准库函数用于打印字符串：puts(),fputs(),printf()
- puts()函数
> 把字符串地址作为参数传递即可,puts把空白符组为结束符，所以字符数组要带上‘\0’,字符串字面量会自动截断并添加空白符结尾
- fputs()函数
> fputs()函数是puts()针对文件的定制版本
> fputs的第二个参数指明要写入数据的文件，如果打印在显示器，则使用标准输出作为参数（stdout）
> 与puts不同，fputs不会在输出的末尾添加换行符
> 注意：gets()丢弃输入中的换行符，puts在输出中添加换行符，fgets()保留输入中的换行符，fputs不在输出中添加换行符
> puts()应与gets()配对使用，fputs()应与fgets()配对使用
- printf()函数
> printf()也把字符串的地址作为参数,printf()不会自动在每个字符串末尾加上一个换行符
- 自定义输入输出函数
> 不一定非要使用C库中的标准函数，也可以自定义自己的函数
- 字符串函数
> c库提供了很多处理字符串的函数，ansi c把这些函数的原型放在string.h头文件中，常用的有strlen(),strcat(),strcmp(),strncmp(),strcpy(),strncpy(),
> sprintf(),
- strlen()函数
> 统计字符串的长度
- strcat()函数
> 用于拼接字符串，接受两个字符串作为参数，把第二个字符串的备份附加到第一个字符串末尾，并把拼接后的字符串作为第一个字符串，第二个字符串不变
> 返回第一个参数，即凭借后第一个字符串的地址
- strncat()函数
> strcat()无法检查第一个数组是否能够容纳第二个字符串，如果分配给第一个数组的空间不够大，多出来的字符溢出到相邻存储单元时就会出问题，
> strncat(str1,str2,int addnum),addnum代表要添加的个数，如果str2中有遇到空字符，还没超过添加个数则挺住添加，如果正好或大约addnum
> 则只添加addnum个，并且在后面加上空字符，任何情况，都是以空字符结尾，要求str1要足够大以容纳这些
> strcat()和 gets()类似，也会导致缓冲区溢出,gets()造成的安全隐患来自于使用该程序的人，而strcat()暴露的问题是那些粗心的程序员造成的
> 无法控制用户会进行什么操作，但是，可以控制你的程序做什么。C语言相信程序员，
> 因此程序员有责任确保strcat()的使用安全
- strcmp()函数
> 字符串比较函数,ansi c 规定，在字母表中如果第一个字符串在第二个字符串前面，strcmp返回一个负数，如果两个字符串相同，返回0，如果第一个字符串在第二个字符串后面则返回整数
> 实现大概是用前面-后面得出差值
- strncmp()函数
> 比较指定长度的字符
- strcpy()和strncpy()函数
> 前面提到过，如果pts1和pts2都是指向字符串的指针，那么下面语句拷贝的是字符串的地址而不是字符串本身
> pts2 = pts1;如果希望拷贝整个字符串，要使用strcpy()函数
> strcpy()接受两个字符串指针作为参数，可以把指向源字符串的第2个指针声明为指针、数组名或字符串常量；
> 而指向源字符串副本的第1个 指针应指向一个数据对象（如，数组），且该对象有足够的空间储存源字符 串的副本。
> 记住，声明数组将分配储存数据的空间，而声明指针只分配储存一个地址的空间。
```
  strcpy()的返回类型是 char *，
  该函数返回的是第 1个参数的值，即一个字符的地址。第二，第 1 个参数不
  必指向数组的开始。这个属性可用于拷贝数组的一部分

```
- strncpy()
> strcpy()和  strcat()都有同样的问题，它们都不能检查目标空间是否能容纳源字符串的副本,拷贝字符串用 strncpy()更安全
> 该函数的第 3 个参数指明可拷贝的最大字符数,
- sprintf()
> sprintf()函数声明在stdio.h中，而不是在string.h中。该函数和printf()类 似，
> 但是它是把数据写入字符串，而不是打印在显示器上。因此，该函数可以把多个元素组合成一个字符串。
> sprintf()的第1个参数是目标字符串的地址。其余参数和printf()相同，即格式字符串和待写入项的列表。
> sprintf()函数获取输入，并将其格式化为标准形式，然后把格式化后的字符串存储在第一个参数内
- 其他字符串函数
```
1:char *strcpy(char* s1,const char * restrict s2);//把s2指向的字符串包括空字符拷贝至s1指向的位置，返回s1
2:char *strncpy(char *s1,const char *s2,size_t n);//将s2指向的字符拷贝至s1指定的位置，拷贝的字符数不超过n,返回s1,
3:char *strcat(char *s1,const char *s2);//将s2拷贝到s1指向的字符串末尾，覆盖空字符，返回s1
4:char *strncat(char *s1,const char *s2,size_t n);//将s1添加至s2末尾，覆盖末尾空字符，并添加一个空字符，该函数返回s1
5:int strcmp(const char *s1,const char *s2);//比较字符串，s1-s2,s1,s2是在机器中的编码序列
6:int strncmp(const char *s1,const char *s2,size_t n);//与上方类似，比较前n个或者遇到空字符停止比较
7:char *strchr(const char *s,int c);//如果s字符串包含字符c,该函数返回指向s的指针，未找到返回空指针
8:char *strbpbrk(const char* s1,const char* s2);//如果s1包含s2中的任意字符，则返回指向s1位置的指针
9:char *strstr(const char *s1,const char* s2);//返回指向s1字符串中s2字符串出现的首位置，如果没有找到s2,返回空指针
10:char * strrchr(const char *s,int c);//该函数返回s字符串中c字符的最后一次出现的位置（末尾的空字符也是字符串的一部分，所以在查找范围内）。果未找到c字符，则返回空指针
11:size_t strlen(const char* s);//返回s字符串中的字符数，不包括末尾的空字符
关键字restrict该关键字限制了函数参数的用法。例如，不能把字符串拷贝给本身
size_t类型是sizeof运算符返回的类型。C规定sizeof运
算符返回一个整数类型，但是并未指定是哪种整数类型，所以size_t在一个
系统中可以是unsigned int，而在另一个系统中可以是 unsigned long。string.h
头文件针对特定系统定义了 size_t，或者参考其他有 size_t定义的头文件
```
-ctype.h字符函数和字符串
> 这些函数用来处理字符，和字符串有一定的关系
- 命令行参数
> $fuccess.exe -r Color
> 一个c程序可以读取并使用这些附加项
```
  1:c编译器允许mian()函数没有参数或者有两个参数（一些实现允许main()有更多参数，属于对标准的扩展），main()有两个参数时
  第一个参数是命令行中的字符串数量，系统用空格表示一个字符串的结束和下一个字符串的开始，程序把命令行字符串存储在内存中，每个字符串的地址存储在指针数组中，
  而该数组的地址则被存在main的第二个参数中，本质上来说，第二个参数是数组的指针，值就是一个地址值，指向数组的第一个地址，然后数组的第一个位置上的值指向内存中第一个参数值的地址
  我们打印的时候其实%s其实就是打印这个参数值的地址，
  char *arg[]与char **arg等价，即char是指针的指针
```
- 把字符串转化为数字
> printf()和sprintf()函数使用%d,scanf()把输入字符串转换为数字，比如函数atoi(),把字符串转换为整数，atio()表示只把开头的整数字符串数字换成整数，
> 如果命令行参数不是数字，atoi()函数返回0。然而C标准规定，这种情况下的行为是未定义的。
> 因此，使用有错误检测功能的strtol()函数（马上介绍）会更安全。atof(),atol(),strtol(),strtoul(),strtod(),
- 关键概念
> 字符串，无论是由字符数组，指针还是字符串常量标识，都存储为包含字符编码的一系列字节，并以空字符串结尾，C提供库函数处理字符串，查找字符串并分析他们，
> 需要牢记，应该使用strcmp()来代替关系运算符，当比较字符串时，应当使用strcpy()或strncpy()代替赋值运算符把字符串赋值给字符数组
- 小结
```
  C字符串是一些列char类型的字符，以空字符('\0')结尾,字符串可以存储在字符数组中，字符串还可以用字符串常量来表示
  里面都是字符，包括在双引号中（空字符除外），编译器提供空字符，因此“yoy”被存储为4个字符，y.o.y.\0,strlen()函数
  可以统计字符的长度，空字符不计算在内，
  
  字符串常量也叫做字符量--字面量，可以用于初始化字符数组，为了容纳末尾的空字符，数组大小应至少比字符串长度多1，也可以使用字符串常量
  初始化指向char的指针
  
  函数使用指向字符串首字符的指针来表示待处理的字符串，通常对应的实际参数是数组名，指针变量或者字符串字面量，无论是哪种情况，传递的都是首字符的地址，
  一般而言，没必要传递字符串的长度，因为函数可以使用末尾的空字符来确定字符串的结束
  
  fgets()函数获取一行输入，puts和fputs函数显示一行输出，他们都是stdio.h头文件中得函数，用于代替已被启用得gets()
  c库中有许多处理字符串得函数，在ansc中，他们声明在string.h文件中，c库还有很多处理字符函数，声明在ctype.h头文件中
  
  给main函数提供两个合适得形式参数，可以让程序访问命令行参数，第一个参数通常是int类型得arg，其值是命令行单词得数量，第二个参数
  通常是一个指向数组得指针，数组内含指向char的指针，每个指向char的指针都指向命令行参数的第一个字符串地址
  
  atoi(),atol(),atof()把字符串形式的数字转换成相应的数字，strtol(),strtoul(),strtod()函数把字符串形式的数字转换为相应的数字类型
  
```
### chapter12: 存储类别，链接和内存管理
-本章要点
> 关键字：auto extern static register const volatile restricted _Thread_local _Atomic
> 函数：rand() srand() time() malloc() calloc() free()
> 如何确定变量的作用域（可见的范围）和声明周期（它存在多长时间），
> 程序员通过 C的内存管理系统指定变量的作用域和生命期，实现对程序的控制
> 合理使用内存储存数据是设计程序的一个要点
- 存储类别
> 从硬件方面来看，被存储的每个值都占用一定的物理内存，C语言把这样的一块内存称为对象
> 从软件方面来看，程序需要一种方法访问对象，可以通过声明变量来完成：int entity=3
> 该声明创建了一个名为entity的标识符，标识符是一个名称，可以用来指定特定对象的内容
> 这里entity标识符即是软件指定硬件内存中对象的方式，该声明还提供了存储在对象的值
```
  一般而言，那些指定对象的表达式被称为左值，（指定内存位置上的内容）
  如果可以使用左值改变对象中的值，该左值就是一个可修改的左值
  
  可以用存储期描述对象，所谓的存储期是指对象在内存中保留了多长时间，标识符用于访问对象，可以使用作用域和链接描述标识符，
  表明程序的哪些部分可以使用它
  
```
- 作用域
> 一个C变量的作用域可以是快作用域，函数作用域，函数原型作用域，或者文件作用域
> 函数的形参也属于函数的块级,函数作用域仅用于goto语句的标签，这意味着即使一个标签首次出现在函数内层
> 块中，它的作用域也延申至整个函数，如果在两个块中使用相同的标签会很混乱，标签的函数作用域防止了这样的事情发生。
> 原型作用域的范围是从形参定义处原型声明结束，只有在变长数组声明中，前面的形参名称才需要对应
> 变量的定义在函数的外面，具有文件的作用域（file SCOPE）,由于这样的变量可以用于多个函数，所以文件作用域变量也称为全局变量
- 翻译单元与文件
> 描述一个具有文件作用域的变量时，它的实际可见范围
> 是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个
> 翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件
- 链接
> C语言有3中链接属性：外部链接，内部链接，无链接
> 具有块作用域，函数作用域，函数原型作用域的变量都是无链接变量，这意味着这些变量属于他们定义的块，函数或者原型私有，具有文件作用域的变量
> 可以是外部链接或者是内部链接，外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用
```
  如何知道文件作用域变量是内部链接还是外部链接？可以查看外部定义中是否使用了存储类别说明符static
  int age=5;//文件作用域，外部链接
  static int price=4;文件作用域，内部链接
  该文件和同一程序中的额其他文件都可以使用变量age,但是变量price属于文件私有，该文件中的任何函数都可以使用它
```
- 存储期
> 作用域和链接描述了描述了标识符的可见性,存储期描述了通过这些标识符访问的对象的生命周期，c对象有四种存储期：静态存储期，线程存储期，自动存储期，
> 动态分配存储期
- 5种存储类别
```
  存储类别        存储期         作用域         链接          声明方式
  自动           自动           块            无            块内
  寄存器         自动           块            无            块内，使用关键字register
  静态外部链接    静态           文件           外部          所有函数外
  静态内部链接    静态           文件           内部          所有函数外，使用关键字static
  静态无链接     静态            块            无            块内，使用关键字static    
```
- 自动变量
> 自动存储类别的变量具有自动存储期，块作用域，且无链接，默认情况下，声明在块或函数头种的任何变量都呼吁自动存储类别，可用auto修饰变量
> 属于存储类别说明符号,块作用域和无链接意味着：只有在变量定义所在的块中，才能通过变量名访问对象，变量具有自动存储类别意味着，程序在进入该变量声明所在的块
> 时，变量存在，程序退出块时，变量消失，原本该变量占用的内存位置现在可做他用
- 寄存器变量
> 变量通常存储在计算机内存中，如果幸运的话，寄存器变量存储在cpu的寄存器中，或者概括的说，存储在最快的可用内存中,与普通变量相比，访问和处理这些变量的速度更快
> 由于寄存器变量存储在寄存器而非内存中,所以无法获取寄存器变量的地址，绝大多数情况下，寄存器变量和所有的自动变量一样，他们都是块作用域,无链接和自动存储期
> 使用存储类别说明符号register标识符:register int num，编译器必须根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略你的请求，所以可能不会如你所愿
> 这种情况下，寄存器变量就会变成自动变量，但是你仍然不能使用地址运算符,也可以在函数原型中声明，可声明的变量类型有限，寄存器可能无法存储大类型数据
- 块作用域的静态变量
> 静态变量听起来自相矛盾，像是一个不可变的量，实际上静态的意思是该变量在内存中原地不动，并不是说他的值不变，
> 具有文件作用域的变量自动具有（也必须是）静态存储期，但是也有静态存储期，块作用域的局部变量，程序离开函数时，他们并不会消失
> 不允许在函数形参中使用static
> 局部静态变量是描述具有块作用域的静态变量的另一个术语
- 外部链接的静态变量
> 外部链接的静态变量具有文件作用域，外部链接和静态存储期，该类别有时称为外部存储类别
> 把变量的定义性声明放在所有函数外面便创建了外部变量，可以使用extern修饰变量标识符,如果该变量在另一个文件中被使用到本源代码，则必须使用extern修饰符
> 外部变量的作用域：从声明处到文件结尾，要想在某个函数内使用外部变量需要使用：extern
- 初始化外部变量
> 外部变量和自动变量类似，也可以被显示初始化，与自动变量不同的是，如果未初始化外部变量，他们会被自动初始化为0，这一情况也适用于数组
> 注意：只能使用常量表达式初始化文件作用域变量
``` 
  int x=5;//ok,5是常量
  size_t z=sizeof(int);//ok,是常量表达式（只要不是变长数组，sizeof可被视为常量表达式）
  int x2=2*x;//不行，x是变量
  不要用关键字extern创建外部定义，只用它来引用现有的外部定义
  外部变量只能初始化一次，且必须在定义该变量时进行

```
- 内部链接的静态变量
> 内部链接的静态变量具有静态存储期，文件作用域和内部链接，在所有函数外部，并用存储类别说明符static修饰
> 变量标识符: static int num=1;可以使用extern存储类别说明符重复声明任何具有文件作用域的变量
- 存储类别和函数
> 函数也有存储类别，可以式外部函数（默认）或静态函数，或者是内联函数，外部函数可以被其他文件的
> 函数访问，但是静态函数只能用于其定义所在的文件，通常的做法是：用 extern 关键字声明定义在其他文件中的函数。
> 这样做是为了表明当前文件中使用的函数被定义在别处。除非使用static关键字，否则一般函数声明都默认为extern。
- 存储类别的选择
> 保护性程序设计的黄金法则是：“按需知道”原则。尽量在函数内部解决该函数的任务，
> 只共享那些需要共享的变量。除自动存储类别外，其他存储类别也很有用。不过，在使用某类别之前先要考虑一下是否有必要这样做
- 随机函数和静态变量
> 参考代码：r_drive1.c
- 掷色子游戏
> 参考代码 manydice.c
- 分配内存：malloc()和free()
> 一般情况下，在确定使用哪种存储类别后，根据已经制定好的内存管理规则，将自动选择其作用域和存储期，然而还有更灵活的选择，即用库函数分配和管理内存
> 回顾一下内存分配：所有程序都必须预留足够的内存来存储程序使用的数据，这些内存中有些是自动分配的，如：float x; char palce[]="asas"
> 为一个float类型的值和一个字符串预留了足够的内存，或者可以显式指定分配一定数量的内存:int plates[100];
```
  该声明预留了100个内存位置，每个位置都用于存储int类型的值，声明还为内存提供了一个标识符，因此可以使用x或者plates识别数据，静态数据在程序载入内存时分配
  而自动数据在程序执行块时分配，并在程序离开该块时销毁
  
  c也可以在程序运行时分配更多的内存，主要的工具是malloc()函数，该函数接受一个参数：所需的内存字节数，malloc()找到合适空闲的内存块，这样的内存是匿名的，
  malloc()分配内存，但是不会为其赋名，它返回动态分配内存块的首字节地址，可以把它赋值给一个指针变量，返回通常被 定义为指向char的指针
  但是最新的c开始使用：指向void的指针，即通用指针，该函数可用于返回指向数组，结构的指针，所以返回值会被强制类型转换为匹配的类型，然而把指向void的指针
  赋值给任意类型的指针不用考虑类型匹配的问题，如果分配内存失败，将返回空指针
  
  通常malloc()函数要与free()函数配合使用，free()函数的参数是之前malloc()函数返回的地址，该函数释放之前函数分配的内存，因此，动态分配内存的存储期
  从调用malloc()分配内存到调用free()释放内存为止，其参数是一个指针，指向malloc分配的一块内存，不能用free释放通过其他方式分配的内存（入声明一个数组）

```
- free的重要性
> 静态内存的数量在编译时是固定的，在程序运行期间也不会改变，自动变量使用的内存数量在程序执行期间自动增加或减少，但是动态分配的内存数量只会增加，除非使用
> free()进行释放
- calloc()函数
> 分配内存也可以使用calloc()函数，和malloc()函数类似，也是返回指向char的指针，在ansi之后，返回指向void的指针，接受两个无符号整数作为参数，第一个时所需存储单元数量，
> 第二个是存储单元大小（以字节为单位），它还有个特点，把块中的所有位置都设置为0,(在某些系统中，不是把所有的位置设置为0来标识浮点值)，该函数分配的内存也可以被free()回收
- 动态内存分配和变长数组
> 变长数组VLA和调用malloc()在功能上有些类似，例如都能用于创建在运行时确定大小的数组
```
  int n;
  int * ptd;
  scanf("%d",&n);
  ptd=(int *)malloc(n*sizeof(int));
  int arr[n];
  ptd[2]=arr[2]=-5;
  ...
  
  不同的是：变长数组是自动存储类型，因此程序在离开变长数组所在的块时，变长数组占用的空间将会被释放，不必使用free();
  另一个方面，malloc()创建的数组不必局限在一个函数内访问，例如，可以这样做：被调函数创建一个数组并返回指
  针，供主调函数访问，然后主调函数在末尾调用free()释放之前被调函数分配的内存，free()和malloc()的指针变量可以不同，但是都必须指向相同
  的存储地址，同一个内存不能被释放两次
  
  int n=5;
  int m=6;
  int arr[n][m];//n*m变长数组VLA
  int (*arr)[6];//C99之前的写法--arr指向内含6个int类型值的数组
  int (*arr)[m];//变长数组指针
  arr1=(int(*)[6])malloc(n*6*sizeof(int));//n*6数组
  arr2=(int(*)[m])malloc(n*m*sizeof(int));//n*m数组
  arr[1][2]=arr1[1][2]=arr2[1][2]
```
- 存储类别和动态内存分配
> 存储类别和动态内存分配有何联系？我们来看一个理想化的模型，可以认为程序把可用的内存分为三个部分，一部分
> 供具有外部链接，内部链接，无链接的静态变量使用，一部分供自动变量使用，一部分供动态内存分配,
> 静态存储类别所用的内存数量在编译时就确定了，只要程序还在运行，就可访问存储在该部分得数据，该类别得变量在程序开始执行时创建，程序结束时被销毁
> 然而，自动存储类别的变量在程序进入变量定义所在的块时存在，在程序离开块时消失，因此，随着程序调用函数和函数结束，自动变量所用的内存数量也想用的
> 增加或减少，这部分的内存通常作为栈来处理，这以为这新创建的变量按照顺序加入内存，然后以相反的顺序销毁
> 动态分配的内存在调用malloc()或相关函数时存在，在调用free()后释放，这部分的内存由管理员管理，而不是一套规则
> 所以内存块可以在一个函数中创建，在另一个函数中销毁，正式因为这样，这部分的内存用于动态内存分配会支离破碎，也就是说，未使用的内存块
> 分散在已使用的内存块之间，另外使用动态内存通常比使用栈内存慢
> 总之，程序把静态对象，自动对象和动态分配的对象催出在不同的区域
- ansi c类型限定符
> 我们通常用类型和存储类别来描述一个变量，C90新增了两个属性：恒常性，易变性 const volatile来形容，以这两个关键字创建出的类型是限定类型，C99新增第三个
> 限定符：restrict，用于提高编译器优化，C11新增第四个：_Atomic,以支持并发程序设计
> C99规定可以在一条声明中使用多个同一限定符，多余的将被忽略：typedef const int zip;const zip q=9;
- const 类型限定符
> 以const声明的对象，不能通过赋值，递增，递减来修改
```
1:在指针和形参中使用const
  const float * f   <==> float const * f; //f指向一个float类型的const值
  float * const f; //f是一个const指针
  const float * const f;//f指向一个const值且该指针也不能改变
  -- const 放在*左边的任意位置，限定了指针指向的数据不能改变，放在*右边的任意位置，限定指针本身不能改变
  const还用来限定函数形参不改变原来数据的大小
2:对全局数据使用const
  全局数据是一个危险数据，程序的任何部分都能使用，使用const限定不能修改，例如创建const 变量，数组，结构
  在文件间共享const数据要小心，有两种方法，第一：遵循外部变量的规则，即在一个文件中使用定义式声明，在另一个文件中使用引用式声明（extern）
  第二：把const变量放在一个头文件中，然后在其他文件中包含该头文件（这种方案必须在头文件中用关键字static声明全局const变量，不然导致每个文件中都有一个相同标识符的定义式声明）
  这种方案相当于给每个文件提供了一个单独的数据副本，无法用这些数据通信，但是他们是const没有关系，不需要修改
      头文件的好处是偷懒，但是他们其实是给每个文件提供了一个相同的副本，不能用于通信，且数据过大时要考虑是否值得
  
```
- volatile类型限定符
> volatile限定符告诉计算机，代理（而不是变量所在的程序），可以改变变量的值，通常它被用于硬件地址以及其他程序或同时运行的线程中共享数据
```
  volatile int local;//local是一个易变的位置
  volatile int * local;//local是一个指向易变的位置的指针
  可以在声明中同时使用const volatile:
    const volatile int local;
    const volatile int * local;
```
- restrict限定类型
> restrict关键字允许编译器优化某部分代码以更好的支持计算，只能用于指针，表明指针是访问
> 数据对象的唯一且初始的方式，如下：
```
  int arr[10];
  int * restrict point=(int *)malloc(10*sizeof(int));
  int * arrs=arr;
  这里 point指针是访问由malloc()分配内存的唯一且初始的方式，因此可以使用restrict限定
  arrs既不是访问数组的初始化方式也不是唯一方式，所以不用设置restrict
  restrict  限定符还可用于函数形参中的指针。这意味着编译器可以假定在函数体内其他标识符不会修改该指针指向的数据
    void * memcpy(void * restrict s1, const void * restrict s2, size_t n);
    void * memmove(void * s1, const void * s2, size_t n);
    这两个函数都从位置s2把n字节拷贝到位置s1。memcpy()函数要求两个
    位置不重叠，但是memove()没有这样的要求。声明s1和s2为restrict说明这两
    个指针都是访问相应数据的唯一方式，所以它们不能访问相同块的数据。这
    满足了memcpy()无重叠的要求。memmove()函数允许重叠，它在拷贝数据时
    不得不更小心，以防在使用数据之前就先覆盖了数据
  restrict关键字有两个读者，一个是编译器，该关键字告诉编译器可以自由假定一些优化方案，另一个读者是用户，该关键字告诉用户要用此关键字需要满足其使用需求
  不然后果自负，
```
- _Atomic类型限定符
> 并发程序设计把程序执行分成可以同时执行的多个线程，如何管理访问相同数据的不同线程，值得注意的是：
> 要通过各种宏函数来访问原子的类型，当一个线程对一个原子类型的对象执行原子操作时，其他线程不能访问该对象
```
_Atomic int hogs;//原子类型的变量
atomic_store(&hogs,12);//原子赋值操作
```
- 旧关键字的新位置
> C99允许把类型限定符和存储类别说明符static放在函数原型和函数头的形参的初始方括号中，新旧对比如下：
```
  指针表示法和数组表示法都可以使用这两个限定符
  旧语法：
    void paly(int * const a1,int * restrict a2,int n);
  新语法：
    void paly(int a1[const],int a2[restrict],int n);
    
  static的情况不同，因为新标准为static引入了一种与以前用法不相关的新用法,
  static除了表明静态存储类别变量的作用域或链接外，新的用法告知编译器如何使用形式参数:
  double stick(double arr[static 20]);  
    static 表明，函数中调用的这个参数应该是一个指向数组首元素的指针，且元素至少有20个，这种用法的目的是：
    让编译器使用之歌信息优化函数的编码，为何给static新增一个完全不同的用法？C 标准委员
    会不愿意创建新的关键字，因为这样会让以前用新关键字作为标识符的程序
    无效。所以，他们会尽量利用现有的关键字，尽量不添加新的关键字
```
- 关键概念
```
  C提供了多种管理内存的模型，除了熟悉这些模型外，还要学会如何选择不同的类别，大多数情况下
  最好选择自动变量，如果要使用其他类别，应该有充分的理由，通常使用自动变量，函数形参和返回值
  进行函数见的通信比使用全局变量更安全，但是保持不变的数据适合使用全局变量
  
  应该尽量理解静态内存，自动内存和动态分配内存的属性，尤其要注意，静态内存的数量在编译时确定，
  静态数据在载入程序时被载入内存，在程序运行时，自动变量被分配或释放，所以自动变量占用的内存数量
  随着程序的运行会不断变化，可以把自动内存看作是可重复利用的工作区，动态分配的内存也会增加和减少，
  但是这是由函数调用控制的，不是自动进行的

```
- 本章小结
```
  1:内存用于存储程序中的数据，由存储期，作用域和链接表征，存储期可以是静态的，自动的，或者是动态分配的
    如果是静态存储期，在程序开始执行时分配内存，并在程序运行时都存在，如果是自动存储期，在程序进入变量
    定义所在块时分配变量的内存，在程序离开块时释放内存.如果是动态分配存储期，在调用malloc()或相关函数
    时分配内存，在调用free()函数时释放内存
    
  2:作用域决定程序的哪些部分可以访问某数据，定义在所有函数之外的变量具有文件作用域，对位于该变量声明之后的所有函数可见，
   定义在块或作为函数形参内的变量具有块作用域，只对该块以及它包含的块可见
  
  3:链接描述定义在程序某翻译单元中的变量可被链接的程度，具有块作用于的变量是局部变量，无链接，具有文件作用域的变量可以是内部链接或外部链接，
  内部链接意味着只有其定义所在的文件才能使用该变量，外部链接意味着其他文件也可以使用该变量
  
  4:c的5中存储类别
    1：自动--在块中不带存储类别说明符或者auto,具有自动存储期，块作用域，无链接，如果未初始化则值未定义
    2：寄存器--在块中带register存储类别说明符，具有自动存储期，块作用域，无链接，且无法获取其地址，要求编译器将其
      存储到访问速度最快的区域，如果未初始化，则是未定义
    3:静态、无链接--在块状中带static存储说明修饰符，具有静态存储期，块作用域，无链接，只在编译时被初始化一次，
      如果未被显示初始化，则都为0
    4:静态、外部链接--所有函数外部且没有使用static,具有静态存储期，文件作用域，外部链接，只能在编译期被初始化一次，
      如果未显示初始化，则全部设置为0
    5:静态、内部链接--在所有函数外部，且使用的static修饰符，具有静态存储期，文件作用域，内部链接，只能在编译期被初始化一次，
      如果未显示初始化，则全部设置为0
  
  动态分配的内存由malloc()或相关函数分配，该函数返回一个指向指定字节数内存块的指针，这块内存被free()释放后可重复使用，free()
  函数以该内存块地址作为参数
  
  类型限定符const,volatile,restrict,_Atomic,
    const限定符限定数据在程序运行时不可改变，针对指针使用时限定指针不可改变或指向的数据不可改变，这取决于const在声明中的位置
    volatile表明，限定的数据除了被当前程序修改之外还可以被其他程序修改，浸膏编译期不要进行优化
    restrict限定符也是为了方便编译期优化，限定的指针时访问他所指向数据的唯一途径         
```

### chapter13: 文件输入/输出
- 与文件进行通信
> 方式1是程序与文件进行交互：重定向> < ,例如books > booklist
> 方式2是提供更强大的文件通讯方法，可以在成勋中打开文件，使用特殊的I/O函数读取，写入文件
```
  1:文件是什么
    文件通常是在磁盘或者固态硬盘上一段已命名的存储区，对我们而言stdio.h就是一个文件的名称，该文件包含一些有用的信息
    然而对操作系统而言，文件更复杂一些，
    C把文件看作是一些列连续的字节，每个字节都能被单独的读取，C提供两种文件模式：文本模式和二进制模式
  2:文本模式和二进制模式
    所有文件内容都已二进制形式存储，但是在存储之前如果使用特定二进制的编码字符表示文本，则文件就是文本文件
    其中包含文本内容，如果文件中的二进制值代表机器语言或者图片内容，则文件就是二进制文件，包含二进制内容
    UNIX用同一种文件格式处理文本文件和二进制文件的内容，\n标识换行，在MacOS中使用\r回车标识新的一行
    windows使用\r\n标识新的一行
  为了规范文本的处理，c提供两种访问文件途径，二进制模式和文本模式，二进制模式中程序可以访问文件的每个字节，
  文本模式中，程序所见内容和文件实际内容不同，读取文件时把行末尾映射为c模式，写入时恢复原来模式  
```
- I/O的级别
> 除了选择文件的模式，大多数情况下，还可以选择I/O的两个级别（即处理文件访问的两个级别）。
> 底层I/O（low-level I/O）使用操作系统提供的基本I/O服务。标准高级I/O（standard  high-level  I/O）
> 使用C库的标准包和stdio.h头文件定义。因为无法保证所有的操作系统都使用相同的底层I/O模型，
> C标准只支持标准I/O包。有些实现会提供底层库，但是C标准建立了可移植的I/O模型，我们主要讨论这些I/O
- 标准文件
> C程序会自动打开三个文件：标准输入，标准输出，标准错误输出，在默认情况下，标准输入是系统的普通输入设备，通常为键盘；
> 标准输出和标准错误输出是系统的普通输出设备，通常为显示屏
```
  通常标准输入为程序提供输入，它是getchar()和scanf()使用的文件，程序通常输出到标准输出，它是putchar(),puts(),printf()使用的文件
  重定向把其他文件视为标准输入/输出，标准错误输出提供了额一个逻辑上不同的地方来发送错误信息，如使用重定向将输出发送到文件而不是屏幕，那么发送至标准错误输出
  的内容仍然会被发送到屏幕上
  
```
- 标准I/O
> 与底层IO相比，标准IO除了可移植外还有两个好处：1：专门函数简化了处理不同IO的问题，2：输入和输出都是缓冲的，一次转移一块信息而不是一个字节，
> 根据ANSI  C的规定，在最初调用的main()中使用return与调用exit()的效果相同,即 return 0==>exit(0)
> 但是要注意，我们说的是“最初的调用”。如果main()在一个递归程序中，
> exit()仍然会终止程序，但是return只会把控制权交给上一级递归，直至最初的一级。然后return结束程序。
> return和exit()的另一个区别是，即使在其他函数中（除main()以外）调用exit()也能结束整个程序
- fopen()函数
> 包含2个参数，第一个表示文件名称（char类型指针 数据地址），第二个参数标识标识读写的模式，该函数返回一个指向文件FILE的指针
> 文件指针并不指向实际的文件，他指向一个包含文件信息的数据对象，其中包含操作文件的IO函数所用的缓冲区信息，该对象属于一个C结构
- getc()/putc()函数
> 类似于getchar()/putchar()，不同的时需要告知使用哪个文件
> ch=getchar()==>ch=getc(fp),putc(ch,stdout);
- 文件结尾
> 如何告诉程序已经到达文件结尾？getc(fp)读到文件结尾时将返回特殊值EOF
- fclose()函数
> 关闭fp指定的文件，必要时刷新缓冲区，成功关闭返回0，否则返回EOF
- 指向标准文件的指针
> stdio.h头文件将三个文件指针与三个标准文件相关联，c程序会自动打开这三个标准文件
```
  标准文件          文件指针          通常使用设备
  标准输入          stdin             键盘
  标准输出          stdout            显示器
  标准错误          stderr            显示器
这些文件指针都是指向FILE的指针  
```
- 一个简单的文件压缩程序
> 详情见reducto.c
- 文件I/O
```
 fprintf()与fscanf()函数
 类似于printf()与scanf(),区别在于前者需要用第一个参数指定待处理文件，详见addaword.c
 fgets()与fputs()函数
 类似gets,fgets(buf,stlen,fp);读取输入知道第一个换行符后面或者文件结束或者读取stlen-1个字符
 然后在末尾添加一个空字符使其称为字符串
 字符串的大小是其字符数加上一个空字符。
 如果fgets()在读到字符上限之前已读完一整行，它会把表示行结尾的换行符放在空字符前面
 
 fputs()函数接受两个参数：第1个是字符串的地址；第2个是文件指针。
 该函数根据传入地址找到的字符串写入指定的文件中。和 puts()函数不同，
 fputs()在打印字符串时不会在其末尾添加换行符
 
 由于fgets()保留了换行符，fputs()就不会再添加换行符，它们配合得非常好
```
- 随机访问fseek()与ftell()
> 有了fseek()函数，就可以把文件看作是数组，在fopen打开的文件中直接移动到任意字节处，
> fseek()有3个参数，返回int类型的值；ftell()函数返回一个long类型的值，表示文件中的当前位置
> 见代码reverse.c
```
  fseek():第一个参数是FILE指针，指向待查文件，fopen已经打开该文件
  第二个参数是偏移量offset,标识从起点开始要偏移的距离，long类型数值，正数前移，负数后移，0保持不动
  第三个参数是模式，该参数确定起点，有三个起点明示常量：SEEK_SET:文件开始处，SEEK_END:文件结束处，SEEK_CUR:当前位置
  返回值0代表正常，返回值-1代表错误
  
  ftell():返回值类型是long,返回当前位置，也就是距离文件开始到当前位置的字节数
  在最初实现的UNIX中，ftell()通过返回距文件开始处的字节数来确定文件的位置，以二进制模式打开的这样处理，以文件形式打开的话可能不对
```
- fgetpos()与fsetpos()函数
> fseek()和 ftell()潜在的问题是，它们都把文件大小限制在 long 类型能表示的范围内,ANSI  C新增了两个处理较大文件的新定位函数：fgetpos()和 fsetpos()
> 这两个函数不使用 long 类型的值表示位置，它们使用一种新类型：fpos_t（代表file  position  type，文件定位类型）。 
> fpos_t类型不是基本类型，它根据其他类型来定义。fpos_t  类型的变量或数据对象可以在文件中指定一个位置，它不能是数组类型，
> 除此之外，没有其他限制。实现可以提供一个满足特殊平台要求的类型，例如，fpos_t可以实现为结构。
 ```
  int fgetpos(FILE * restrict stream, fpos_t * restrict pos);
  调用该函数时，它把fpos_t类型的值放在pos指向的位置上，该值描述了
  文件中的一个位置。如果成功，fgetpos()函数返回0；如果失败，返回非0。
  
  int fsetpos(FILE *stream, const fpos_t *pos);
  调用该函数时，使用pos指向位置上的fpos_t类型值来设置文件指针指向
  该值指定的位置。如果成功，fsetpos()函数返回0；如果失败，则返回非0。
  fpos_t类型的值应通过之前调用fgetpos()获得
```
- 标准I/O的机理
> 注意理解标准io的工作原理-P977
- 其他标准IO
```
  1: int ungetc(int c,FILE *fp);//把c指定的字符放回输入流，如果把一个字符放回输入
    流，下次调用标准输入函数时将读取该字符，如果实现允许把一行中的多个字
    符放回输入流，那么下一次输入函数读入的字符顺序与放回时的顺序相反
  2:int fflush()函数
    int fflush(FILE *fp);
    调用fflush()函数引起输出缓冲区中所有的未写入数据被发送到fp指定的
    输出文件。这个过程称为刷新缓冲区,如果  fp是空指针，所有输出缓冲区
    都被刷新。在输入流中使用fflush()函数的效果是未定义的。只要最近一次操
    作不是输入操作，就可以用该函数来更新流（任何读写模式）。
  3:int setvbuf()
    int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size);
    setvbuf()函数创建了一个供标准I/O函数替换使用的缓冲区。在打开文件
    后且未对流进行其他操作之前，调用该函数
  4:fread()/fwrite()
    对于标准 I/O，fread()和 fwrite函数用于以二进制形式处理数据 
    把二进制数据写入文件:
    size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp); 
      指针ptr是待写入数据块的地址,size表示待写入数据块的大小（以字节为单位）
      nmemb表示待写入数据块的数量,fp指定待写入的文件
        要保存一个大小为256字节的数据对象（如数组），可以这样做:
        char buffer[256]
        fwrite(buffer,256,1,fp)
        fwrite()函数返回成功写入项的数量。正常情况下，该返回值就是nmemb，但如果出现写入错误，返回值会比nmemb小
        
    读取被fwrite()写入文件的数据:    
    size_t fread(void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp);
      ptr是待读取文件数据在内存中的地址,fp指定待读取的文件    
      fread(buffer,256,1,fp);//恢复保存在char字节对象数组，把一个256大小的字节块拷贝进buffer数组中
      fread()函数返回成功读取项的数量。正常情况下，该返回值就是nmemb，但如果出现读取错误或读到文件结尾，该返回值就会比nmemb小  
``` 
- int feof(FILE *fp)和int ferror(FILE *fp)函数
> 如果标准输入函数返回EOF,通常表达函数已经到达文件结尾，然而读取错误时也会返回EOF,上面两个函数正式用于区分这种情况
> 当检测到文件末尾时，feof()返回一个非零值，否则返回0，当出现错误时ferror()返回一个非零值，否则返回0
- 一个实例程序
> 把一些列文件的内容附加再另一个文件的末尾,设计方案如下：
```
  1：询问目标文件的名称并打开它
  2：使用一个循环询问源文件
  3：以读模式依次打开源文件，并将及添加到目标文件结尾
  4：详细代码见append.c

```
- 用二进制I/O进行随机访问
> 详细代码见randbin.c源代码
> 随机访问是用二进制I/O写入二进制文件最常用的方式
- 关键概念
```
  c程序把输入看作是字节流输入流来源于文件，输入设备（如键盘），或者甚至是另一个程序的输出，类似的，c程序把输出也看做字节流，
  输出流的目的地可以是文件，视频显示等
  
  c如何解释输入流输出流取决于所使用的输入输出函数，程序可以不做任何改动的读取和存储字节，或者把字节依次解释成字符，随后可以把这些字符
  解释成普通文本以用文字表示数字，类似的，对于输出，所使用的函数决定了使用二进制是被原样转移，还是被转换成文本或以文本表示数字，
  如果要在不损失精度的前提下保存或恢复数值数据，请使用二进制模式并且使用fread,fwrite函数，如果打算保存文本信息并创建能在普通文本
  编辑器查看的文本，请使用文本模式和函数（如getc(),fprintf())
  
  要访问文件，必须创建文件指针，类型是FILE * 并把指针与特定文件名相连，随后就可以使用这个指针操作文件了
  
  c如何处理文件结尾，通常用于读取文件的程序使用一个循环读取输入，直至到达文件结尾，c输入函数在读过文件结尾后才会检测到文件结尾
  这意味着应该尝试读取文件后立即判断是否到达结尾，参考file_test.c中while部分以及前后代码

```
- 小结
```
  对于大多数c程序而言，写入文件和读取文件必不可少，为此绝大多数c实现都会底层I/O和高级标准I/0，因为ansic考虑到可以执行问题，包含了标准IO,
  但是并未包含底层IO
  
  标准IO包自动创建输入和输出缓冲区以加快数据传输，fopen函数为标准IO打开一个文件，并创建一个用于存储文件和缓冲区信息的结构，
  fopen函数返回指向该结构的指针，其他函数可以使用该指针指定待处理的文件，feof()和ferror()函数报告IO失败的原因
  
  c把输入视为字节流,如果使用fread函数，c把输入看作二进制并将其存储在指定位置，如果使用fscanf(),getc(),fgets()或其他相关函数，c
  将每个字节看作是字符码，然后fscanf,scanf函数尝试把字符码翻译成转换说明指定的其他类型，getc,fgetc系列函数把输入作为字符码存储，
  将其作为单独的字符保存在字符变量中或作为字符串存储在字符数组中，类似的，fwrite将二进制数据直接放入输出流，而其他输出函数把非非字符数据
  转换成字符表示后才将其放入输出流
  
  ansic 提供两种文件打开模式，二进制和文本，以二进制模式打开文件时，可以逐字节读取文件，以文本模式打开文件时，会把文件内容从从文本的系统
  表示法映射为c表示法，对于linux/unix而言，这两种模式完全相同
  
  通常，输入函数getc(),fgets(),fscanf(),fread()都从文件开始处按顺序读取文件，然而，fseek()和ftell()函数让程序可以随机访问文件中的任意位置，
  fgetpos(),fsetpos()把类似的功能扩展到更大的文件，与文本模式相比，二进制模式更容易进行随机访问
```

### chapter14: 结构和其他数据形式
- 一个例子
> book.c案例
- 建立结构声明
> 使用结构必须掌握三个技巧：1：为结构建立一个格式或样式，2：声明一个适合该样式的变量，3：访问结构变量的各个部分
```
  1:建立结构声明
  类似如下结构布局，有时候结构声明又称为模板：
  struct book{//结构模板，标记是book
    char title[MAX_TITLE];
    char author[MAX_AUTH];
    float value;
  };
  成员可以是任意数据类型，甚至可以是其他结构
  可以把这个声明放在所有函数的外部，也可以把声明放在一个函数的内部定义，放在内部就仅限于函数内部使用，
  放在外部则该声明之后的所有函数都可以使用
  
  2:定义结构变量
  结构在声明时没有分配空间，只有在声明结构变量时，才会为结构体分配内存空间
  可以声明结构变量，也可以声明指向类型结构的指针：struct book1,book2,*ptbook
  struct book library;
  是以下声明的简化：
  struct book{
  char name[10];
  char addr[20];
  float value;
  } library;
    初始化结构：
      struct book library={
        "name1",
        "name2",
        12.4
      };
      如果初始化静态存储期的变量，必须使用常量值，这一点也适用于结构
    结构的初始化器：
      使用.运算符和成员名称=> struct book library={.value=32.33};
  
  3:结构数组
  见many_book.c源代码    
    声明数组结构：struct book library[num]
    标识结构数组的成员：library[2].title[4]==》library数组的第三个结构变量的书名的第五个字符
    
  4:嵌套结构
  一个结构中包含另一个结构  
  
  5:指向结构的指针
  使用理由：1：就像指向数组的指针那样比数组本身更容易操控，指向结构的指针通常比结构本身更容易操控
  2：在一些早期c语言中，结构不能作为参数传递给函数，但是结构指针可以
  3：即使能传递一个结构，传递指针通常更有效率
  4：一些用于表示数据的结构中包含指向其他结构的指针
    struct guy *him;如果struct guy test,  him=&test
    和数组不同的是，结构名并不是地址，因此需要在名称前面加上&地址运算符
    用指针访问成员：
      1:him->inCome==>test.inCome
      2:(*him).inCome,(*him)代表着test,必须使用(),因为.优先级高于*
    总之，如果him是指向guy类型结构test的指针，则下面的关系恒成立（假设him=&test）
      test.inCome=(*him).inCome=him->inCome
      
  6:向函数传递结构的信息
    1：传递结构成员
      只要结构成员是一个具有单个值的数据类型（int,char，float,double或指针），就可以将结构成员当作参数传递
    2：传递结构的地址
    3：传递结构本身
    4：其他结构特性
      现在的c允许把一个结构赋值给另一个结构，但是数组不能这么做，但是数组不能这样做
      相同类型的结构存在如下：o_data=n_data;即使成员是数组也能完成
      还可以把一个结构初始化为相同类型的另一个结构：
        struct names orage={"xjh","color"};
        struct names copy=orage;
    5:把结构作为返回值返回
      其作用与传递结构指针类似，指针传递地址，然后操作原始
      传递结构返回结构，是操作副本，然后将副本赋值给原始结构  
    6：结构和结构指针的选择：
      把指针作为参数有两个优点，无论是以前还是现在的c都能使用，而且很快，只需要传递一个地址
      缺点是无法保护数据，不过使用const可以解决这个问题
      把结构作为参数传递的优点是，处理的额是原始数据的副本，保护了数据，缺点是可能老的实现无法处理这样的程序
      浪费存储空间和时间
         通常，程序员为了追求效率会使用结构指针作为函数参数，如需防止原
始       数据被意外修改，使用const限定符。按值传递结构是处理小型结构最常
用       的方法。     
    7：结构中的字符数组和字符指针
      对于结构中得字符数组，字符都存储在结构内部，对于字符指针，结构本身只存储两个地址值，即char类型长度，一个8字节
      其中得字符串存储在编译器存储常量得地方，此结构不用为字符串分配任何存储空间，只分配变量本身得内存，用来管理那些
      已分配和在别处分配得字符串，所以声明得时候不初始化，后面去引用它有可能会出现问题，例如：
      scanf("%s",params.name1),如果parames是struct  params{char * name1,char *name2}
      这里存在潜在得风险，所以最好是使用指针指向已经分配内存和在别处分配内存得字符串
    8：结构，指针和malloc()
      如果使用malloc()分配内存并使用指针存储该地址，那么在结构中使用指针就较为合理，因为可以请求malloc()
      为字符串分配合适得存储空间，见代码 names.c
    9：复合字面量和结构
      c99的复合字面量特性可用于结构和数组，如果只需要一个临时结构复合字面量很好用，例如，可以使用复合字面量创建一个数组作为函数
      的参数或赋给另一个结构。语法是把类型名放在圆括号中，后面紧跟一个用
      花括号括起来的初始化列表。例如，下面是struct book类型的复合字面量：
      （struct book）{"first","last",99.8}  
      还可以把复合字面量作为函数的参数。如果函数接受一个结构，可以把复合字面量作为实际参数传递：
          struct rect {double x; double y;};
          double rect_area(struct rect r){return r.x * r.y;}   
          
      如果函数接受一个地址，可以传递复合字面量的地址：
      struct rect {double x; double y;};
      double rect_areap(struct rect * rp){return rp->x * rp->y;}   
      area = rect_areap( &(struct rect) {10.5, 20.0}); 
      复合字面量在所有函数的外部，具有静态存储期，如果复合字面量在块中，则具有自动存储期，复合字面量和普通初始化列表的
      语法规则相同，这意味着可以在复合字面量中使用指定初始化器
    10：伸缩型数组成员
      最后一个数组成员具有一些特性，第一个特性是：该数组不会立即存在，第二个特性是：使用这个伸缩型数组成员
      可以编写合适代码，
      规则：
        1：伸缩型数组成员必须是结构的最后一个成员
        2：结构中必须至少有一个成员
        3：伸缩型数组声明类似普通数组，只是他的方括号中是空的
        struct book{
            int age;
            double average;
            double scores[];//伸缩型数组成员
        }
      该意图并不是让你声明一个struct book的变量，而是希望你声明一个指向book类型的指针，然后用malloc()来分配空间，
      以存储book类型结构的常规类容和伸缩型内容：例如，假设用scores表示一个内含5个double类型值的数组，可以这样做；
        struct book *pt;//声明一个指针
        pt=malloc(sizeof(struct book)+5*sizeof(double));//请求为一个结构和数组分配存储空间
        现在有空间存储age,average,scores了
        pt->age=4;pt->aberage=44.23;pt->scores[2]=12.33
      带伸缩性成员的结构，不能用结构进行赋值或拷贝：
        struct book *bk1,*bk2;... *bk1=*bk2//不要这样做
        这样只能拷贝伸缩型数组成员以外的其他成员  
      第二，不要以按值方式把这种结构传递给结构。原因相同，按值传递一个参数与赋值类似。要把结构的地址传递给函数  
      第三，不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的成员
      
      这种类似于在结构中最后一个成员是伸缩型数组的情况，称为structhack。除了伸缩型数组成员在声明时用空的方括号外，
      struct hack特指大小为0的数组。然而，struct hack是针对特殊编译器（GCC）的，不属于C标准。
      这种伸缩型数组成员方法是标准认可的编程技巧
    11：匿名结构
      一个没有名称的结构成员，它与嵌套结构类似，只是在嵌套式省略了名称，同时调用的时候也省略了名称
      struct inner{
        int age;
        char name[20];
      }
      struct outer{
        int id;
        struct inner inner;//嵌套结构
      }
      struct outer ot={23,{23,"sss"}};outer.inner.age
               
      struct outer2{
        int id;
        struct{//匿名结构
          int age;
          char name[20];
        }
      }
      struct outer ot={23,{23,"sss"}};outer.age;//访问时简化了步骤
    12：使用结构数组的函数
      假设一个函数要处理结构数组，由于数组名就是该数组的地址，所以可以把它传递给函数，另外该函数
      还需要访问结构模板  
        要点：1：可以把数组名作为数组中第一个结构的地址传递给函数，但是结构名缺不行
             2：可以用数组表示法访问数组中的其他结构
    13：把结构保存到文件中
      由于结构能存储不同类型的信息，所以他是构建数据库的重要工具，可以通过一个文件流，将结构信息写入，如下：
      fprintf(stream,"%s%s%.2f",book.name,book.author,book.value)
      检索时还存在问题，因为程序要知道一个字段结束和另一个字开始的位置。虽然用固定字段宽度的格式可以解决这个问题（例
      如，"%39s%39s%8.2f"），但是这个方法仍然很笨拙  
        更好的方案是使用fread()和fwrite()函数读写结构大小的单元
        fwrite(&pointer,sizeof(struct book),1,pbooks);
          定位到pointer结构变量开始的位置，并把结构中的所有字节都拷贝到与pbooks相关的文件中，fread与之相反，
          从文件中拷贝一块大小的数据到&pointer指向的位置，两个函数一次读写整个记录而不是一个字段
          缺点是：不容系统甚至同系统之间的二进制表示法可能不相同，文件可能不具备移植性
          代码见booksave.c          
```
- 链式结构
> 结构的特殊形式之一：创建新的数据形式，许多已经发现的性的形式很好用，比如，树，队列，堆，栈，哈希表，图表，许多这样的形式都由链式结构组成
> 通常每个结构都包含一两个数据项和一两个指向其他同类型结构的指针，这些指针把一个结构和另一个结构链接起来，并提供一种路径能便利整个彼此链接的结构
- 联合
> 联合是一种数据类型，它能够在同一个内存空间中存储不同的数据类型（不是同时存储），
> 典型用法是存储及无规律也无顺序的混合类型，使用联合类型的数组，其中的联合都大小相等，每个联合可以存储各种数据类型
> 创建联合和创建结构的方式相同，需要一个联合模板和联合变量，可以一步定义也可分开定义，如下：
```
  声明如下：
  union hold{
    int digit;
    double bigfl;
    char letter;
  }
  以上形式声明的联合表示能存储上述三个类型中任意一种，也只能存储一种，
  定义变量如下：
  union hold ift;//hold类型的联合变量
  union hold save[10];//内含10个联合变量的数组
  union hold *pu;//指向hold类型联合变量的指针
    第一种编译器分配最大类型的存储空间，第二种也是根据最大类型分配数组空间
    第三种创建了一个指针，该指针变量存储联合变量的地址
  初始化联合：
  1：把联合初始化为另一个同类型的联合
    union hold vala;
    vala.letter='R';
    union hold valb=vala;//用另一个联合来初始化
  2：初始化联合的第一个元素
    union hold valc={88};//初始化联合的digit成员
  3：指定初始化器
    union hold vals={.bigfl=118.2};//指定初始化器      
    
  使用联合：
   fit.digit=22;存储int类型，占2字节
   fit.bigfl=12.44;存储浮点数，占8字节
   fit.letter='h';存储字符，占1字节
   用法和结构使用一样，使用&表示地址，使用->表示指向类型
   pu=&fit;
   x=pu->digit 等价于 x=fit.digit
   操作联合时注意当前存储的数据类型，不要前方存储char,后面就把它当作double来用
   联合的另一种用法是，在结构中储存与其成员有从属关系的信息
 匿名联合：
  匿名联合和匿名结构的工作原理相同，即匿名联合是一个结构或联合的无名联合成员
  用起来和匿名结构类似，可以省略部分层次
 总结：结构和联合运算符
  1：成员运算符.,指定结构或联合的一个成员
  2：间接成员运算符->,该运算符和指向结构或联合的指针一起使用，标识结构或联合的一个成员
    假如ps是指向item的结构或联合的指针，则：ps->code==(*ps).code== item.code     
```
- 枚举类型
> 可以用枚举类型声明符号名称来表示整型常量，使用enum关键字，声明如下：
```
  //创建color标记，接下来将enum color作为一个类型名使用
  enum color{
    red,orange,blue,dark//枚举符，是int类型常量，从0开始，每次递增1
  };
  //声明cl作为该类型的变量
  enum color cl;
  C允许枚举变量使用++,但是C++不允许
  enum常量
    只要是能使用整型常量的地方就可以使用枚举常量，例如声明数组时，可以使用
    枚举表示数组大小，switch中可以使用枚举常量作为标签，默认从0开始每次递增1
  赋值
    在枚举声明中，可以为枚举常量指定整数值
    enum level{low=20,midum=50,high=80};
    enum ls{cat,dog=100,pig}
      其中cat为默认值0，pig为递增值101
  enum枚举的用法
    为了提高程序的可读性和可维护性，可以在表达式中使用作为整型常量，详见代码my_enum.c      
```
- 共享名称空间
> c语言使用名称空间namespace标识程序中的各个部分，即通过名称来识别，作用域是名称空间概念的一部分，两个不同
> 作用域的同名变量不冲突，名称空间是分类别的，在特定作用域中的结构标记，联合标记。枚举标记都共享相同的命名空间，该命名空间
> 与普通变量使用的空间不同，这意味着相同作用域中变量和标记的名称可以相同，但是不能在相同作用域中声明两个同名标签或同名变量
```
  在c语言中以下内容是合法的
    struct book{double x,doubley};
    int book;
  在c++中不允许这么做，因为它把标记名和变量名放在相同的命名空间中  
```
- typedef简介
> typedef根据是一个高级数据特性，可以为某一类型自定义名称，这方面与#define类似，但是两者有三处不同：
```
  1:与#define不同，typedef创建的符号只受限于类型，不能用于值
  2：typedef由编译器解释，不是预处理器
  3：在其受限范围内，typedef比#define更灵活
  使用：
  typedef unsigned char BYTE;//用BYTE标识一字节数字
    BYTE x,y[10],*z;
    该定义的作用域取决于typedef定义所在的位置，如果定义在函数中，就具有局部作用域，受限于定义所在的函数
    如果定义在函数外面，就具有文件作用域
  通常typedef定义中用大写字母表示被定义的名称，以提醒用户整个类型名称实际上是一个符号缩写，当然也可以用小写
  为现有类型创建一个名称，看上去多此一举，但有时候确实很有用
  用BYTE 代替unsigned char 标识你可能用BYTE变量表示数字而不是字符码
    提高可移植性，参见sizeof返回值类型size_t以及time()函数返回值类型，time_t
    他们的返回类型在不同的系统上可能是不同的整数类型，让具体实现使用typedef来设置它二点具体类型
  与#define功能有相似的地方：
    #define BYTE unsigned char;//使预处理器用BYTE替代unsigned char
    typedef char *spring;//如果没有typedef,编译器将把spring标识为一个指向cahr的指针
          但是有了typedef,编译器则把spring解释成一个类型的标识符，该类型是指向char的指针
            spring name,sign;
          等价于：
            char * name,*sign;
          如果这样：
            #define spring char *
            spring name,sign;==>char * name,sign;==>这将导致name才是指针，sign为char类型变量
    typedef还可以用于结构：
      typedef struct complex{
        float va1;
        float va2;
      } COMPLEX;  
      然后就可以使用COMPLEX代替complex结构，这样的好处是经常出现的地方可以使用此方便，易识别的类型名
      还可以省略结构的标签:
      typedef struct{
        double x;
        double y;
      } rect;         
      rect r1={22.4,23.45};
      rect r2;
      r2=r1//对于类型相同的，将r1的值赋值给r2  
    typedef常用于给复杂的类型命名：
      typedef char(* FRTPC())[5];
        把FRTPC声明为一个函数类型，该函数返回一个指针，该指针指向内含5个char类型元素的数组
    typedef不创建任何新类型，只为某个已存在的类型增加一个方便使用的标签，以前期面的spring类型变量为例子
    它可以作为实参传递给以指向char指针作为形参的函数
```
- 其他复杂的声明
> *表示一个指针，()表示一个函数 []表示一个数组
```
  int board[8][8];//声明一个内含int数组的数组
  int ** ptr;//声明一个指向指针的指针，被指向的指针，被指向的指针指向int
  int * risk[10];//声明一个内含10个元素的数组，每个元素都是一个指向int的指针
  int(*risk)[10];//声明一个指向数组的指针，该数组内包含10个int值
  int *risk[3][4];//声明一个3*4的二维数组，每个元素都是指向int的指针->为12个指针预留空间
  int(*risk)[3][4];//声明一个3*4二维数组的指针，该数组内含12个int值->为一个指针预留空间
  int(*risk[3])[4];//声明一个内含三个指针元素的数组，每个指针指向一个内含4个int值的数组->预留2个指针的空间
    //以上：数组名后面的[]和函数名后面的()具有相同的优先级，比*(解引用)优先级高
    //[],()优先级相同，从左往右结合，
  char * func(int);返回字符指针的函数
  char (*func)(int);指向函数的指针，该函数的返回值类型为char
  char (*func[3])(int);内含3个指针的数组，每个指针都指向返回类型为cahr的函数
  可以使用typedef建立一系列相关的类型
  typedef int arr5[5];
  typedef arr5* p_arr5;
  typedef p_arr5 arrp10[10]；
  arr5 togs;//togs是一个内含5个int的数组
  p_arr5 p2;//p2是一个指向数组的指针，该数组内含5个int值
  arrp10 p3;//p3是一个内含10个指针的数组，每个指针指向一个内含5个int的数组
```
- 函数和指针
> 可以声明一个指向函数的指针，通常，函数指针通常作为另一个函数的参数，告诉该函数要使用哪一个函数
> 例如，排序数组涉及比较两个元素，以确定先后。如果元素是数字，可以使用>运算符；
> 如果元素是字符串或结构，就要调用函数 进行比较。C库中的  qsort()函数可以处理任意类型的数组，
> 但是要告诉 qsort()使用哪个函数来比较元素。为此， qsort()函数的参数列表中，有一个 参数接受指向函数的指针。
> 然后，qsort()函数使用该函数提供的方案进行排序，无论这个数组中的元素是整数、字符串还是结构
```
  什么是函数指针，假设有一个指向int类型变量的指针，该指针存储着整个int类型变量存储在内存位置的地址，
  同样，函数也有地址，因为函数的机器语言实现由载入内存的代码组成，指向函数的指针中存储着函数代码的起始处地址，
  其次，声明一个数据指针时，必须声明指针所指向的数据类型，声明一个函数指针时，必须声明指针指向的函数类型，为了指明
  函数类型，要指明函数签名，即函数的返回值类型和参数类型
    函数原型：void toUpper(char *);
    声明指针pf指向该函数类型：void (*pf)(char *);pf是一个指向函数的指针（把函数名替换为*pf是创建函数指针的最简单方式）
    如果没有前面的括号： void *pf (char *); pf是一个返回字符指针（通用指针）的函数
  声明了函数指针后，可以把类型匹配的函数地址赋值给它，在上下文中，一般函数名称可以用于表示函数地址，例如：
  void toUpper(char *);
  int round(double);
  void (*pf)(char *);
  char mis[]="hello";
  pf=toUpper;//有效，toUpper是该类型函数的地址  
  pf=round;//无效，round与指针类型不匹配
  pf=toUpper();//无效，toUpper()不是地址，且返回值类型为void,不能在赋值语句中赋值
  有两种奇怪的函数调用：  
    (*pf)(mis);//语法1
    pf(mis);//语法2
    这两者看起来都合情合理，语法1中，pf是指向函数的指针，则*pf代表着toUpper函数本身
                       语法2中，pf就等价月toUpper(从上面的赋值可以看出pf=toUpper),因为函数名是指针，所以可以和函数名调换使用，函数名代表地址，指针也代表地址
                        他们的区别是：语法1使用了指针的实际值（地址值的解引用），而语法2使用了函数指针的地址值
    k&r支持第一种，伯克利推广支持第二种，ansic默认两种都支持
  函数也可以传参，参看下面函数原型：
 　void show(void (*ps)(char *),char * str);
    声明了两个形参：ps,str,ps是一个指向函数的指针，str是一个数据指针
    可以这样调用该函数：show(toUpper,mis);
    或者：show(pf,mis);  
 该函数内如何调用指针函数？如下：
 void show(void(*pf)(char *),char *str){
  (*pf)(str);把所选函数用作与str
 }                  
 
 把带返回值的函数作为参数传递给另一个函数有两种不同的方式
  function1(sqrt);//传递sqrt()函数地址
  function2(sqrt(4.0));//传递sqrt()函数的返回值
  
 参考代码func_ptr.c
  函数名的四种用法：
    定义函数：int complex(double x ,double y){...};
    声明函数：int complex(double,double);
    调用函数：int state=complex(5,6);
    作为指针：int (*pf)(double,double); pf=complex;

```
- 关键概念
```
  1：C结构可以把复杂的信息放在一个单元内，可以开发一个与结构配套的函数，这样在修改结构时
  只需要修改函数，不需要修改函数调用
  2：联合的声明和结构类似，但是它只能存储一项内容，内存分配也是以最大那项来分配。成员共享相同的
  存储空间
  3：enum枚举工具提供了一种定义符号常量的方法，typedef工具提供一种为基本类或派生类创建新标识的方法
  4：指向函数的指针提供一种告诉函数应该使用哪一个函数的方法
```
- 小结
```
  c结构提供在相同的数据对象中存储多个不同类型数据项的方法，可以使用标记来标识一个具体的结构模板
  并声明该类型的变量，通过点.运算符访问成员变量
  
  有一个指向结构的指针，可以使用指针和间接成员运算符->代替结构.成员变量来访问各个成员，和数组不同
  结构名不是结构的地址，需要在前面加上地址符号&
  
  结构传递到函数一般是传递结构的指针，但是也允许传递结构和返回结构，同时也支持同类型结构间的赋值
  
  联合与结构的用法相同
  
  枚举可以创建一系列代表整数常量的符号和定义相关联的枚举类型
  
  typedef工具可以用于建立c标准类型的别名或缩写
  
  函数名代表函数的地址，可以把函数的地址作为参数传递给其他函数，如果把特定的函数地址赋值给一个名为pf
  的函数指针，则可以通过以下两种方式调用
  （*pf）(args);
  pf(args);
```

### chapter15: 位操作
- 
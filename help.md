## C Primer Plus Six Edition
### chapter1:初识C语言
- 目标代码、可执行文件和库
> 将源代码编译成可执行文件:源代码经过编译器编译为目标代，链接器将目标代码，启动代码以及库代码合成一个文件，即可执行文件，被计算机识别执行
> 编译器会创建一个与源代码基本名称相同的目标代码文件，扩展名为.o,一旦连接器生成了可执行文件就会删除目标代码文件，如果源代码文件有多个，则会保留目标代码文件

- 可移植性
> 完美的可移植性程序是指，其源代码无需修改的情况下就能在不同的计算机系统中成功的编译的程序

- 源代码、目标代码、可执行文件的区别
> 源代码文件包含程序员使用的任何语言编写的代码，目标代码文件包含及其语言代码，他不是完整的程序代码
> 而可执行文件包含组成可执行文件的完整机器语言代码

- 编程的7个步骤
> 定义程序目标 设计程序 编写程序 编译程序 运行程序 测试和调整程序 维护和修改程序

- 编译器的作用
> 编译器把源代码翻译成等价的及其语言代码（也叫目标代码）

- 链接器的作用
> 链接器把编译器翻译好的源代码以及库代码和启动代码组合起来，生成一个可执行程序
### chapter2:C语言概述
- 典型的C程序组成部分
  ```
    1:#include--->预处理指令
    2:int main(void)--->main()总是第一个被调用的函数
    3:function a()、function b()-->函数是C程序的构造块
        包含语句
        C语言中的6中语句:1：标号语句
                      2：复合语句
                      3：表达式语句
                      4：选择语句
                      5：迭代语句
                      6：跳转语句
        由关键字、标识符、运算符、数据组成
  ```
- C语言的基本模块是什么
> 他们都叫做函数

### chapter3:数据和C
- 计算机得存储方式
> 整数类型和浮点数类型 int long short unsigned signed void char float double _Bool _Complex _Imaginary
- unsigned与signed的区别
> unsigned用于表示无符号位数据，其将符号位化为二进制，用于非负值的场合，标识的数值比有符号位要大
> 同时signed强调使用有符号类型的意图：比如：short   short int    signed short int     signed short都表示的是同一种类型
> 其他辅助int类型的比如 long int / long long int
- 为什么使用多种整数类型
> C语言规定short占用的存储空间不能比int多，long占用的存储空间不能比int少
> 现代计算机最常见的设置是long long占用64位，long占用32位，short占用16位，int占用16、32位，依据计算机的自然字长而定
> l/L后缀表示long类型 ll/LL后缀表示long long类型，可以用作10，8，16这些不同进制的整数
> u/U后缀表示unsigned long long 例如：5ull 8llu 11ULL 7LLU
- 打印short、long、long long和unsigned类型
> 打印unsigned int类型使用%u,打印long类型的使用%ld,%lx表示以16进制格式打印long类型
> %lo表示以8进制格式打印long类型整数
> 对于short类型，%hd表示以10进制显示short类型整数，%ho表示以8进制显示，%hx
> h和l前缀都可以和u一起使用，用于表示无符号类型，例如：%lu表示打印unsigned long类型
> %llu,%lld分别表示无符号，有符号 long long类型数据
> 虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写(格式化响应类型数据时可以使用规则内的大小写切换)
> 例如L/l 0x/0X 
- 字符常量
> 在C语言中，用单引号括起来的单个字符被称为字符常量,双引号括起来的成为字符串
> 实际上，字符是以数值形式储存的，所以也可使用数字代码值来赋值
> char grade = 'A';==》char grade = 65
- 用八进制或十六进制表示字符
> beep='\a'==>beep='\007'
> beeps='\x010'==>beeps='\X10'
> 八进制使用反斜杠\+1-3位数字  十六进制使用\x+1-3位数字
- 有符号还是无符号
> 有些C编译器把char实现为有符号类型，这意味着char可表示的范围 
> 是-128～127。而有些C编译器把char实现为无符号类型，那么char可表示的 
> 范围是0～255。根据C90标准，C语言允许在关键字char前面使用signed或unsigned。
> 这样，无论编译器默认char是什么类型，signed  char表示有符号类型，
> 而unsigned  char表示无符号类型。这在用char类型处理小整数时很有用。
> 如果只用char处理字符，那么char前面无需使用任何修饰符。
- float,double,long double
> c语言规定float类型必须至少能够表示6位有效数字，且取值范围至少是10 -37 ～10 +37
> double类型浮点数为双精度数，他和float最小取值范围相同，但是至少必须能表示10位有效数字
> 一般情况下double占用64位而不是32位
- 浮点数常量
> 浮点型常量得基本形式是：有符号得数字（包括小数点），后面紧跟e/E,最后是一个有符号数表示10的指数
> -2.1E+12   2.334e3 2.3    2.   .3  .4e-6   
> 正号可以省略，可以没有小数点或指数部分，但不能同时省略两者，可以省略小数或整数部分，但不能同时省略2者
- 打印浮点数值
> %f 打赢十进制计数法浮点数  %e打印指数计数法浮点数  %a，%A打印16进制
> 打印long double需要使用%Lf %Le %La
- 浮点数的上溢和下溢
> 当计算导致数字过 大，超过当前类型能表达的范围时，就会发生上溢,
> C语言规定，在这种情况下会赋一个表示无穷大的特定值，而且printf()显示该值为inf或infinity
> float类型的数以指数和尾数部分来储存,假设存在一个最小的浮点数，即指数部分是最小值，其他的全部位数表示最小的位数值
> 现在将该值除以2，理论上这个操作会减小指数值，，但是指数值已经是最小的了，计算机只能将后面的尾数值向右位移一位，左边
> 空出一个二进制位，并丢弃最右边的一位二进制数，虽然得到了结果，
> 但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫 作下溢（underflow）
> 因此，把最小的正浮点数除以 2将得到一个低于正常的值。如果除以一个非常大的值，会导致所有的位都为0
- 复数和虚数类型
> 简而言之，C语言有三种复数类型：float_Complex,double_Complex,long double_Complex
> 例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部
> C语言的三种虚数类型：float_Imaginary,double_Imaginary,long double_Imaginary
- 小结：基本数据类型
```
 关键字：
  基本数据类型由11个关键字组成：int,long,char,short,unsigned,float,double,signed
  _Bool,_Complex,_Imaginary
 有符号整形：
  有符号整形可以表示正整数和负整数
  int->系统给定的基本整数类型，C语言规定int类型不小于16位
  short/short int->最大的short类型整数小于或等于最大的int类型整数，C语言规定short类型至少占16位
  long/long int->该类型表示的整数大于或等于最大的int类型整数,long至少占32位
  long long/long long int->该类型可表示的整数大于或等于最大的long型整数，long long至少占64位
  一般而言：long类型占用的内存比short大，int类型的宽度要么和long相同，要么和short相同，旧DOS系统的PC提供16位的
  short和int，以及32位的long；Windows 95系统提供16位的short以及32位的int和long
 无符号型：
  无符号整形只能表示正数和零，因此可表示的正整数要比有符号的大，在整形类型前面加上unsigned即可
 字符类型：
  可打印出来的符号都是字符，char类型表示一个字符需要占用一个字节内存，处于历史原因，一个字节通常是8位，但是如果要表示基本字符
  也可以是16位或者更大
  char->字符类型的关键字，有些编译器使用有符号的char,有些使用无符号的char,在需要是可以明确定义 signed unsigned
 布尔类型：
  true/false C语言使用1表示true,0表示false
  _Bool->布尔类型的关键字，是无符号的int类型，占用的空间只要能存储0、1即可
 实浮点类型：
  表示正浮点数和负浮点数，float->系统的基本浮点类型，可精确表示至少6位有效数字
  double->存储浮点数的范围更大，能表示比float类型更多的有效数字（至少10位，通常更多）和更大的指数
  long long->存储浮点数的范围可能比double更大，能表示比double更多的有效数字和更大的指数
 复数和虚数浮点数
  虚数类型是可选的，复数的实部和虚部类型都是基于实浮点数来构建的
  float_Complex,double_Complex,long double_Complex
  float_Imaginary,double_Imaganiary,long double_Imaginary  
  小结：如何声明简单变量
  1：选择需要的类型
  2：使用有效的字符给变量起一个名字
  3：按照以下格式声明：
    类型说明符 变量名；
    说明符由一个或多个关键字组成
      unsigned int errs;
  4：可以同时声明多个同类型变量，用逗号分割变量名，如下所示：
    char chs,intss,ans;
  5：在声明的同时还可以初始化变量：
     float mass=3.14E12
```
- 刷新输出
> printf()何时将输出发送到屏幕上？最初printf()语句将输出发送到一个叫做缓冲区（buffer）的
> 中间存储区域，然后缓冲区的内容再不断发送到屏幕上，C标准规定，缓冲区满，遇到换行字符串或者需要输入的时候
> 需要刷新缓冲区（从缓冲区把数据发送到屏幕或文件），还有一种方法就是使用刷新函数fflush()

### chapter4:字符串和格式化输入输出
- char类型数组和null字符
> c语言没有专门的存储字符串的变量类型，字符串都被存储在char类型的数组中，数组由连续的存储单元组成
> 数组的末尾若没有字符就是空字符，用\0表示，空字符不是0，他是非打印字符，其ascii码值是（或等价于）0
> c的字符串一定是以空字符结尾，这意味着数组容量必须至少比带存储的字符串中的字符数多1，
> 数组是同类型数据元素的有序序列

- 使用字符串
> 字符串常量"X",和字符常量‘X’不同：1：‘x’是基本数据类型char,"x"是派生类型（char数组）
> 2：“x”实际上是由两个字符组成：‘x’和‘\0’,以空字符作为字符串的结束
- strlen()函数
> sizeof运算符，他以字节为单位给出对象大小，strlen()给出字符串中的字符长度
> C99 和 C11 标准专门为 sizeof 运算符的返回类型添加 了%zd 转换说明，这对于strlen()同样适用。
> 对于早期的C，还要知道sizeof和strlen()返回的实际类型（通常是unsigned或unsigned long）
- sizeof
> 对于sizeof有时候使用括号，有时候不使用，使用预付取决于对象是类型还是特定量
> 当对象是类型时需要使用: sizeof(int),sizeof(char)
> 当对象是特定量时，可以不使用：sizeof name ;sizeof 6.28 
- 常量和c预处理器
> 变量，c语言可能会无意间修改了值，，对于常量，c提供了一个更好的方案，c预处理器，预处理器也可以用来定义常量，
> 只需在程序顶部添加一行 #define TEXTAREA 0.16,编译程序时，程序中所有的TEXTAREA都会被替换成0.015。
> 这一过程被 称为编译时替换（compile-time substitution）
> =>:#define name value
- const限定符
> 限定一个变量只读：const int mouth=12;
- printf()
> printf()与scanf()函数又称为输入输出函数，I/O函数
```
  转换说明            输出
  %A/%a             浮点数，十六进制和p计数法
  %c                单个字符
  %d                有符号十进制整数
  %e/%E             浮点数，e计数法
  %f                浮点数，十进制计数法
  %g/%G             根据值的不同，自动选择%f或%e,%e格式用于指数小于-4或者大于或等于精度时
  %i                有符号十进制整数（==%d）
  %o                无符号八进制整数
  %p                指针
  %s                字符串
  %u                无符号十进制整数
  %x/%X             无符号十六进制整数
  %%                打印一个百分号
```
- printf()的转换说明修饰符
> 在%和转换字符之间插入修饰符可修饰基本的转换说明
> 详情请见4.4.3
> 转换说明：%m.nf m指定字段宽度,n指定小数点精度
- 转换说明的意义
> 转换说明把二进制格式存储在计算机中的值转换成一系列字符（字符串）。以便于显示，例如数字76在计算机内部的存储格式
> 是二进制01001100，%d转换说明将其转换成字符7和6，并显示为76，转换说明并不是替换，而是翻译
- printf()函数的返回值
> printf()函数也有一个返回值，它返回打印字符的个数。如果有输出错误，printf()则返回一个负值
- scanf()函数
> C的多个输入函数之一，可以读取不同格式的数据，scanf()把输入的字符串转换成整数，浮点数，字符或字符串，而printf()正好相反，
> 把整数、浮点数、字符、字符串转换成显示在屏幕上的文本，printf()和scanf()函数的区别主要在参数列表
> printf()函数使用常量、变量、表达式，而scanf()函数使用指向变量的指针
> 1：如果scanf()读取基本类型的变量的值，在变量名前加一个&
> 2：如果用scanf()把字符串读入字符数组中，不要使用&
- 其他输入函数
> getchar(),fgets()
- printf()和scanf()的*修饰符
> 如果你不想预先指定字段宽度，希望通过程序来指定，那么可以用*修 
> 饰符代替字段宽度。但还是要用一个参数告诉函数，字段宽度应该是多少。 
> 也就是说，如果转换说明是%*d，那么参数列表中应包含*和 d对应的值。这 
> 个技巧也可用于浮点值指定精度和字段宽度
- 关键概念
- 什么是空白
> 空白包括空格、制表符和换行符。C 语言使用空白分隔记号。
> scanf()使用空白分隔连续的输入项

### chapter5: 运算符，表达式和语句
- 基本运算符
> = + - * /  虽然C没有指数运算符，但是C的标准数学库提供了pow()函数用于指数运算
> 一般来说，变量是可修改的左值，表达式是右值
- sizeof运算符和size_t类型
> sizeof以字节为单位返回运算对象大小，通常返回size_t类型(这是一个无符号整数类型)
> size_t不是新类型，是c语言定义的标准类型typedef double real; real deal,此时deal可以被判断为double类型
> size_t使用C99新增的%zd转换说明 -- 如果编译器不支持%zd，请将其改成%u或%lu
- 负数的求模
> C99规定“趋零截断”，如果第一个运算对象是正数，求模结果为正数，如果第一个运算对象为负数，则求模结果也为负数
> 11/5=2 11%5=1   11/-5=-2  11%-5=1  -11/5=-2 -11%5=-1 -11/-5=2 -11%-5=-1
> 事实上标准规定:无论何种情况，只要a,b都是整数值，便可通过a-(a/b)*b来计算a%b:
> -11%5=>-11-(-11/5)*5=-11-(-2)*5=-11+10=-1
- 自增自减运算符++ --
> ++/--出现在前面的叫做前缀模式，出现在后面的叫后缀模式
> 前缀模式先自增后运算，后缀模式先运算后递增
> 如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符
> 如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。
- 总结C的一些运算符
```
1:赋值运算符：= 将右边的值赋给左边的变量
2：算数运算符 + - * / % ++ --
3:其他运算符：sizeof 获得其右侧运算对象的大小
```
### chapter6: C控制语句：循环
> for while do while 
- 真、假
> 对c语言来说1==true 0==false,即表达式的值为1为真，表达式的值为0为假
> 一般而言，所有非0的值被视作真，只有0被视作假
- _Bool类型
> 只存储两个值，真（1）/假（0），如果把其他非零数值赋给_Bool类型的变量，该变量会被设置为1
> 这反映了C把所有的非零值都视为真
- 优先级与关系运算符
> 关系运算符的优先级比算数运算符（包括+、-）低，比赋值运算符高，
> 与其他大多数运算符一样，关系运算符的结合律也是从左往右，关系运算符之间有两种不同的优先级组
> 高优先级组：< <= > >= 低优先级组 ！=  ==
- 逗号运算符
> 逗号运算符把两个表达式连接成一个表达式，并保证最左边的表达式最先求值
> while循环： 初始化 while(测试){更新}  for(初始化;测试;更新)   初始化  do{更新 }while(测试)
- 字符数组
> 可以把字符串储存在char类型的数组中（一般而言，char类型数组的所有元素都储存char类型的值）。
> 如果char类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成了一个字符串

### chapter7: C控制语句：分支和跳转
- getchar()与putchar()
> getchar()函数不带任何参数，它从输入队列中返回下一个字符：ch=getchar()
> ==>scanf("%c",&ch);
> putchar()函数打印他的参数：putchar(ch):把ch的值作为字符打印出来
> ==》printf("%c",ch);
> 注意 getchar()和 putchar()不需要转换说明,因为它们只处理字符
- 逻辑运算符
> && 或 || 与  ！ 非  iso646.h将这些符号使用关键字替代  and or not
- 优先级
> !运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相 
> 同，只比圆括号的优先级低。&&运算符的优先级比||运算符高，但是两者的 
> 优先级都比关系运算符低，比赋值运算符高。因此，表达式a >b && b > c || 
> b > d相当于((a > b) && (b > c)) || (b > d)。
- 求值顺序(序列点与副作用)
> 除了两个运算符共享一个运算对象的情况外(3*x+2，其中x属于这个情况)，C 通常不保证先对复杂表达式中哪部分求值
> 但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右。&&和||运算符都是序列点，
> 所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。
> 而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值（短路）。
> 例如：while ( x++ < 10 && x + y < 20)    
> =》实际上，&&是一个序列点，这保证了在对&&右侧的表达式求值之前，已经递增了x。
- 范围
> 求90-100之间的判断：if (range >= 90 && range <= 100)，千万不要写成：
> (90<=x<=100),编译器这样理解：(90<=x)<=100，原因是逻辑运算符求值是从左往右：
> 导致前面的结果是一个布尔值（0/1）,即0<=100或者1<=100，这是一个恒为真的判断
- 条件运算符
> expression? expression1:expression2
- continue
> continue还可用作占位符,与其循环中不写任何内容，不如协商continue
> 通常情况下，把if的测试条件的关系反过来便可避免使用continue
- break
> 通常用来推出循环和选择
- 多重选择：switch/break
> 他是if elseif else的变体，用于多重选择
> break语句可用于循环和switch语句，但是continue只能用于循环中，如果switch在一个循环中
> 则可以使用continue,C语言中的switch圆括号中的值必须是一个整数值，包括char类型 (整形表达式)
- 多重标签
> 在switch中可以使用多个case,省略其中的break表示顺序执行,执行其中一个之后无需判断另一个,直接执行(因为其中没有break语句)
- switch一般注解
> 程序根据expression的值跳转至相应的case标签处。然后，执行剩下的所有语句，除非执行到break语句进行重定向。
> expression和case标签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。
> 如果没有case标签与expression的值匹配，控制则转至标有default的语句（如果 有的话）；
> 否则，将转至执行紧跟在switch语句后面的语句。
- goto
> goto part2;
> part2:printf("this is goto statement\n")

### chapter8: 字符输入/输出和输入验证
- 单字符IO:getchar()和putchar()
> 每次只处理一个字符，
- 缓冲输入、无缓冲输入
> 把若干个字符作为一个块输入要提高效率，无缓冲输入在游戏等立刻执行情况下有有用武之地
> 缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中
> 行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区
- 文件结尾
> 通常有两种方法，一种是在文件结尾标记特殊字符（例如ctrl+z）,另外一种是计算文件的大小，当达到指定大小时，
> 就算达到了文件末尾，在c语言中，无论哪种情况，当使用getchar()读取文件监测到结尾时都将返回EOF(End OF File)
> scanf()函数监测到文件结尾时也返回EOF
- 重定向输入（<）
> 假设已经编译了echo_eof.c  程序，并把可执行版本放入一个名为echo_eof（或者在Windows系统中名为echo_eof.exe）的文件中。
> 运行该程 序，输入可执行文件名:echo_eof(windows为echo_eof.exe),该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入。
> 现在，假设你要用该程序处理名为words的文本文件:echo_eof < words (windows为echo_eof.exe<word)
- gcc编译源文件
> gcc echo.c --如果没有指定文件名称，则生成a.out(linux) 或 a.exe(windows)。
> gcc 源文件名 -o 目标文件名  ：gcc hello.c -o target/hello会在 target 目录下生成 hello.exe 文件(Linux 系统生成 hello 可执行文件)
- 重定向输出（>）
> 现在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。
> 然后，输入以下命令并开始输入:echo_eof>mywords 
> 通常会擦除该文件的内容，然后替换新的内容,
> 记住在每行的末尾单击Enter键，这样才能把缓冲区的内容发送给程序
- 组合重定向
> 现在，假设你希望制作一份mywords文件的副本，并命名为savewords。
> 只需输入以下命令即可:echo_eof < mywords > savewords
> 下面的命令也起作用，因为命令与重定向运算符的顺序无关：
> echo_eof > savewords < mywords
- 关于重定向运算符
> 重定向运算符连接一个可执行程序（包括标准操作系统命令）和一个数据文件，
> 不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序。
> 使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件
- 追加运算符（>> 运算符）
> 该运算符可以把数据添加到现有文件的末尾,而 | 运算符能把一个文件的输出连接到另一个文件的输入
- 小结
> prog>file:将输出重定向至文件， prog<file:将输入重定向至文件
> prog>file1<file2 prog<file2>file1  这两种形式都是把file2作为输入、file1作为输出
- 输入验证
> 简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值。
> 使用转换说明（如%d或%f）限制了可接受输入的字符类型，而getchar()和使用%c的scanf()接受所有的字符。

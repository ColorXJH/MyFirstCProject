## C Primer Plus Six Edition
### chapter1:初识C语言
- 目标代码、可执行文件和库
> 将源代码编译成可执行文件:源代码经过编译器编译为目标代，链接器将目标代码，启动代码以及库代码合成一个文件，即可执行文件，被计算机识别执行
> 编译器会创建一个与源代码基本名称相同的目标代码文件，扩展名为.o,一旦连接器生成了可执行文件就会删除目标代码文件，如果源代码文件有多个，则会保留目标代码文件

- 可移植性
> 完美的可移植性程序是指，其源代码无需修改的情况下就能在不同的计算机系统中成功的编译的程序

- 源代码、目标代码、可执行文件的区别
> 源代码文件包含程序员使用的任何语言编写的代码，目标代码文件包含及其语言代码，他不是完整的程序代码
> 而可执行文件包含组成可执行文件的完整机器语言代码

- 编程的7个步骤
> 定义程序目标 设计程序 编写程序 编译程序 运行程序 测试和调整程序 维护和修改程序

- 编译器的作用
> 编译器把源代码翻译成等价的及其语言代码（也叫目标代码）

- 链接器的作用
> 链接器把编译器翻译好的源代码以及库代码和启动代码组合起来，生成一个可执行程序
### chapter2:C语言概述
- 典型的C程序组成部分
  ```
    1:#include--->预处理指令
    2:int main(void)--->main()总是第一个被调用的函数
    3:function a()、function b()-->函数是C程序的构造块
        包含语句
        C语言中的6中语句:1：标号语句
                      2：复合语句
                      3：表达式语句
                      4：选择语句
                      5：迭代语句
                      6：跳转语句
        由关键字、标识符、运算符、数据组成
  ```
- C语言的基本模块是什么
> 他们都叫做函数

### chapter3:数据和C
- 计算机得存储方式
> 整数类型和浮点数类型 int long short unsigned signed void char float double _Bool _Complex _Imaginary
- unsigned与signed的区别
> unsigned用于表示无符号位数据，其将符号位化为二进制，用于非负值的场合，标识的数值比有符号位要大
> 同时signed强调使用有符号类型的意图：比如：short   short int    signed short int     signed short都表示的是同一种类型
> 其他辅助int类型的比如 long int / long long int
- 为什么使用多种整数类型
> C语言规定short占用的存储空间不能比int多，long占用的存储空间不能比int少
> 现代计算机最常见的设置是long long占用64位，long占用32位，short占用16位，int占用16、32位，依据计算机的自然字长而定
> l/L后缀表示long类型 ll/LL后缀表示long long类型，可以用作10，8，16这些不同进制的整数
> u/U后缀表示unsigned long long 例如：5ull 8llu 11ULL 7LLU
- 打印short、long、long long和unsigned类型
> 打印unsigned int类型使用%u,打印long类型的使用%ld,%lx表示以16进制格式打印long类型
> %lo表示以8进制格式打印long类型整数
> 对于short类型，%hd表示以10进制显示short类型整数，%ho表示以8进制显示，%hx
> h和l前缀都可以和u一起使用，用于表示无符号类型，例如：%lu表示打印unsigned long类型
> %llu,%lld分别表示无符号，有符号 long long类型数据
> 虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写(格式化响应类型数据时可以使用规则内的大小写切换)
> 例如L/l 0x/0X 
- 字符常量
> 在C语言中，用单引号括起来的单个字符被称为字符常量,双引号括起来的成为字符串
> 实际上，字符是以数值形式储存的，所以也可使用数字代码值来赋值
> char grade = 'A';==》char grade = 65
- 用八进制或十六进制表示字符
> beep='\a'==>beep='\007'
> beeps='\x010'==>beeps='\X10'
> 八进制使用反斜杠\+1-3位数字  十六进制使用\x+1-3位数字
- 有符号还是无符号
> 有些C编译器把char实现为有符号类型，这意味着char可表示的范围 
> 是-128～127。而有些C编译器把char实现为无符号类型，那么char可表示的 
> 范围是0～255。根据C90标准，C语言允许在关键字char前面使用signed或unsigned。
> 这样，无论编译器默认char是什么类型，signed  char表示有符号类型，
> 而unsigned  char表示无符号类型。这在用char类型处理小整数时很有用。
> 如果只用char处理字符，那么char前面无需使用任何修饰符。
- float,double,long double
> c语言规定float类型必须至少能够表示6位有效数字，且取值范围至少是10 -37 ～10 +37
> double类型浮点数为双精度数，他和float最小取值范围相同，但是至少必须能表示10位有效数字
> 一般情况下double占用64位而不是32位
- 浮点数常量
> 浮点型常量得基本形式是：有符号得数字（包括小数点），后面紧跟e/E,最后是一个有符号数表示10的指数
> -2.1E+12   2.334e3 2.3    2.   .3  .4e-6   
> 正号可以省略，可以没有小数点或指数部分，但不能同时省略两者，可以省略小数或整数部分，但不能同时省略2者
- 打印浮点数值
> %f 打赢十进制计数法浮点数  %e打印指数计数法浮点数  %a，%A打印16进制
> 打印long double需要使用%Lf %Le %La
- 浮点数的上溢和下溢
> 当计算导致数字过 大，超过当前类型能表达的范围时，就会发生上溢,
> C语言规定，在这种情况下会赋一个表示无穷大的特定值，而且printf()显示该值为inf或infinity
> float类型的数以指数和尾数部分来储存,假设存在一个最小的浮点数，即指数部分是最小值，其他的全部位数表示最小的位数值
> 现在将该值除以2，理论上这个操作会减小指数值，，但是指数值已经是最小的了，计算机只能将后面的尾数值向右位移一位，左边
> 空出一个二进制位，并丢弃最右边的一位二进制数，虽然得到了结果，
> 但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫 作下溢（underflow）
> 因此，把最小的正浮点数除以 2将得到一个低于正常的值。如果除以一个非常大的值，会导致所有的位都为0
- 复数和虚数类型
> 简而言之，C语言有三种复数类型：float_Complex,double_Complex,long double_Complex
> 例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部
> C语言的三种虚数类型：float_Imaginary,double_Imaginary,long double_Imaginary
- 小结：基本数据类型
```
 关键字：
  基本数据类型由11个关键字组成：int,long,char,short,unsigned,float,double,signed
  _Bool,_Complex,_Imaginary
 有符号整形：
  有符号整形可以表示正整数和负整数
  int->系统给定的基本整数类型，C语言规定int类型不小于16位
  short/short int->最大的short类型整数小于或等于最大的int类型整数，C语言规定short类型至少占16位
  long/long int->该类型表示的整数大于或等于最大的int类型整数,long至少占32位
  long long/long long int->该类型可表示的整数大于或等于最大的long型整数，long long至少占64位
  一般而言：long类型占用的内存比short大，int类型的宽度要么和long相同，要么和short相同，旧DOS系统的PC提供16位的
  short和int，以及32位的long；Windows 95系统提供16位的short以及32位的int和long
 无符号型：
  无符号整形只能表示正数和零，因此可表示的正整数要比有符号的大，在整形类型前面加上unsigned即可
 字符类型：
  可打印出来的符号都是字符，char类型表示一个字符需要占用一个字节内存，处于历史原因，一个字节通常是8位，但是如果要表示基本字符
  也可以是16位或者更大
  char->字符类型的关键字，有些编译器使用有符号的char,有些使用无符号的char,在需要是可以明确定义 signed unsigned
 布尔类型：
  true/false C语言使用1表示true,0表示false
  _Bool->布尔类型的关键字，是无符号的int类型，占用的空间只要能存储0、1即可
 实浮点类型：
  表示正浮点数和负浮点数，float->系统的基本浮点类型，可精确表示至少6位有效数字
  double->存储浮点数的范围更大，能表示比float类型更多的有效数字（至少10位，通常更多）和更大的指数
  long long->存储浮点数的范围可能比double更大，能表示比double更多的有效数字和更大的指数
 复数和虚数浮点数
  虚数类型是可选的，复数的实部和虚部类型都是基于实浮点数来构建的
  float_Complex,double_Complex,long double_Complex
  float_Imaginary,double_Imaganiary,long double_Imaginary  
  小结：如何声明简单变量
  1：选择需要的类型
  2：使用有效的字符给变量起一个名字
  3：按照以下格式声明：
    类型说明符 变量名；
    说明符由一个或多个关键字组成
      unsigned int errs;
  4：可以同时声明多个同类型变量，用逗号分割变量名，如下所示：
    char chs,intss,ans;
  5：在声明的同时还可以初始化变量：
     float mass=3.14E12
```
- 刷新输出
> printf()何时将输出发送到屏幕上？最初printf()语句将输出发送到一个叫做缓冲区（buffer）的
> 中间存储区域，然后缓冲区的内容再不断发送到屏幕上，C标准规定，缓冲区满，遇到换行字符串或者需要输入的时候
> 需要刷新缓冲区（从缓冲区把数据发送到屏幕或文件），还有一种方法就是使用刷新函数fflush()

### chapter4:字符串和格式化输入输出
- char类型数组和null字符
> c语言没有专门的存储字符串的变量类型，字符串都被存储在char类型的数组中，数组由连续的存储单元组成
> 数组的末尾若没有字符就是空字符，用\0表示，空字符不是0，他是非打印字符，其ascii码值是（或等价于）0
> c的字符串一定是以空字符结尾，这意味着数组容量必须至少比带存储的字符串中的字符数多1，
> 数组是同类型数据元素的有序序列

- 使用字符串
> 字符串常量"X",和字符常量‘X’不同：1：‘x’是基本数据类型char,"x"是派生类型（char数组）
> 2：“x”实际上是由两个字符组成：‘x’和‘\0’,以空字符作为字符串的结束
- strlen()函数
> sizeof运算符，他以字节为单位给出对象大小，strlen()给出字符串中的字符长度
> C99 和 C11 标准专门为 sizeof 运算符的返回类型添加 了%zd 转换说明，这对于strlen()同样适用。
> 对于早期的C，还要知道sizeof和strlen()返回的实际类型（通常是unsigned或unsigned long）
- sizeof
> 对于sizeof有时候使用括号，有时候不使用，使用预付取决于对象是类型还是特定量
> 当对象是类型时需要使用: sizeof(int),sizeof(char)
> 当对象是特定量时，可以不使用：sizeof name ;sizeof 6.28 
- 常量和c预处理器
> 变量，c语言可能会无意间修改了值，，对于常量，c提供了一个更好的方案，c预处理器，预处理器也可以用来定义常量，
> 只需在程序顶部添加一行 #define TEXTAREA 0.16,编译程序时，程序中所有的TEXTAREA都会被替换成0.015。
> 这一过程被 称为编译时替换（compile-time substitution）
> =>:#define name value
- const限定符
> 限定一个变量只读：const int mouth=12;
- printf()
> printf()与scanf()函数又称为输入输出函数，I/O函数
```
  转换说明            输出
  %A/%a             浮点数，十六进制和p计数法
  %c                单个字符
  %d                有符号十进制整数
  %e/%E             浮点数，e计数法
  %f                浮点数，十进制计数法
  %g/%G             根据值的不同，自动选择%f或%e,%e格式用于指数小于-4或者大于或等于精度时
  %i                有符号十进制整数（==%d）
  %o                无符号八进制整数
  %p                指针
  %s                字符串
  %u                无符号十进制整数
  %x/%X             无符号十六进制整数
  %%                打印一个百分号
```
- printf()的转换说明修饰符
> 在%和转换字符之间插入修饰符可修饰基本的转换说明
> 详情请见4.4.3
> 转换说明：%m.nf m指定字段宽度,n指定小数点精度
- 转换说明的意义
> 转换说明把二进制格式存储在计算机中的值转换成一系列字符（字符串）。以便于显示，例如数字76在计算机内部的存储格式
> 是二进制01001100，%d转换说明将其转换成字符7和6，并显示为76，转换说明并不是替换，而是翻译
- printf()函数的返回值
> printf()函数也有一个返回值，它返回打印字符的个数。如果有输出错误，printf()则返回一个负值
- scanf()函数
> C的多个输入函数之一，可以读取不同格式的数据，scanf()把输入的字符串转换成整数，浮点数，字符或字符串，而printf()正好相反，
> 把整数、浮点数、字符、字符串转换成显示在屏幕上的文本，printf()和scanf()函数的区别主要在参数列表
> printf()函数使用常量、变量、表达式，而scanf()函数使用指向变量的指针
> 1：如果scanf()读取基本类型的变量的值，在变量名前加一个&
> 2：如果用scanf()把字符串读入字符数组中，不要使用&
- 其他输入函数
> getchar(),fgets()
- printf()和scanf()的*修饰符
> 如果你不想预先指定字段宽度，希望通过程序来指定，那么可以用*修 
> 饰符代替字段宽度。但还是要用一个参数告诉函数，字段宽度应该是多少。 
> 也就是说，如果转换说明是%*d，那么参数列表中应包含*和 d对应的值。这 
> 个技巧也可用于浮点值指定精度和字段宽度
- 关键概念
- 什么是空白
> 空白包括空格、制表符和换行符。C 语言使用空白分隔记号。
> scanf()使用空白分隔连续的输入项

### chapter5: 运算符，表达式和语句
- 基本运算符
> = + - * /  虽然C没有指数运算符，但是C的标准数学库提供了pow()函数用于指数运算
> 一般来说，变量是可修改的左值，表达式是右值
- sizeof运算符和size_t类型
> sizeof以字节为单位返回运算对象大小，通常返回size_t类型(这是一个无符号整数类型)
> size_t不是新类型，是c语言定义的标准类型typedef double real; real deal,此时deal可以被判断为double类型
> size_t使用C99新增的%zd转换说明 -- 如果编译器不支持%zd，请将其改成%u或%lu
- 负数的求模
> C99规定“趋零截断”，如果第一个运算对象是正数，求模结果为正数，如果第一个运算对象为负数，则求模结果也为负数
> 11/5=2 11%5=1   11/-5=-2  11%-5=1  -11/5=-2 -11%5=-1 -11/-5=2 -11%-5=-1
> 事实上标准规定:无论何种情况，只要a,b都是整数值，便可通过a-(a/b)*b来计算a%b:
> -11%5=>-11-(-11/5)*5=-11-(-2)*5=-11+10=-1
- 自增自减运算符++ --
> ++/--出现在前面的叫做前缀模式，出现在后面的叫后缀模式
> 前缀模式先自增后运算，后缀模式先运算后递增
> 如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符
> 如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。
- 总结C的一些运算符
```
1:赋值运算符：= 将右边的值赋给左边的变量
2：算数运算符 + - * / % ++ --
3:其他运算符：sizeof 获得其右侧运算对象的大小
```
### chapter6: C控制语句：循环
> for while do while 
- 真、假
> 对c语言来说1==true 0==false,即表达式的值为1为真，表达式的值为0为假
> 一般而言，所有非0的值被视作真，只有0被视作假
- _Bool类型
> 只存储两个值，真（1）/假（0），如果把其他非零数值赋给_Bool类型的变量，该变量会被设置为1
> 这反映了C把所有的非零值都视为真
- 优先级与关系运算符
> 关系运算符的优先级比算数运算符（包括+、-）低，比赋值运算符高，
> 与其他大多数运算符一样，关系运算符的结合律也是从左往右，关系运算符之间有两种不同的优先级组
> 高优先级组：< <= > >= 低优先级组 ！=  ==
- 逗号运算符
> 逗号运算符把两个表达式连接成一个表达式，并保证最左边的表达式最先求值
> while循环： 初始化 while(测试){更新}  for(初始化;测试;更新)   初始化  do{更新 }while(测试)
- 字符数组
> 可以把字符串储存在char类型的数组中（一般而言，char类型数组的所有元素都储存char类型的值）。
> 如果char类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成了一个字符串

### chapter7: C控制语句：分支和跳转
- getchar()与putchar()
> getchar()函数不带任何参数，它从输入队列中返回下一个字符：ch=getchar()
> ==>scanf("%c",&ch);
> putchar()函数打印他的参数：putchar(ch):把ch的值作为字符打印出来
> ==》printf("%c",ch);
> 注意 getchar()和 putchar()不需要转换说明,因为它们只处理字符
- 逻辑运算符
> && 或 || 与  ！ 非  iso646.h将这些符号使用关键字替代  and or not
- 优先级
> !运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相 
> 同，只比圆括号的优先级低。&&运算符的优先级比||运算符高，但是两者的 
> 优先级都比关系运算符低，比赋值运算符高。因此，表达式a >b && b > c || 
> b > d相当于((a > b) && (b > c)) || (b > d)。
- 求值顺序(序列点与副作用)
> 除了两个运算符共享一个运算对象的情况外(3*x+2，其中x属于这个情况)，C 通常不保证先对复杂表达式中哪部分求值
> 但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右。&&和||运算符都是序列点，
> 所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。
> 而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值（短路）。
> 例如：while ( x++ < 10 && x + y < 20)    
> =》实际上，&&是一个序列点，这保证了在对&&右侧的表达式求值之前，已经递增了x。
- 范围
> 求90-100之间的判断：if (range >= 90 && range <= 100)，千万不要写成：
> (90<=x<=100),编译器这样理解：(90<=x)<=100，原因是逻辑运算符求值是从左往右：
> 导致前面的结果是一个布尔值（0/1）,即0<=100或者1<=100，这是一个恒为真的判断
- 条件运算符
> expression? expression1:expression2
- continue
> continue还可用作占位符,与其循环中不写任何内容，不如协商continue
> 通常情况下，把if的测试条件的关系反过来便可避免使用continue
- break
> 通常用来推出循环和选择
- 多重选择：switch/break
> 他是if elseif else的变体，用于多重选择
> break语句可用于循环和switch语句，但是continue只能用于循环中，如果switch在一个循环中
> 则可以使用continue,C语言中的switch圆括号中的值必须是一个整数值，包括char类型 (整形表达式)
- 多重标签
> 在switch中可以使用多个case,省略其中的break表示顺序执行,执行其中一个之后无需判断另一个,直接执行(因为其中没有break语句)
- switch一般注解
> 程序根据expression的值跳转至相应的case标签处。然后，执行剩下的所有语句，除非执行到break语句进行重定向。
> expression和case标签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。
> 如果没有case标签与expression的值匹配，控制则转至标有default的语句（如果 有的话）；
> 否则，将转至执行紧跟在switch语句后面的语句。
- goto
> goto part2;
> part2:printf("this is goto statement\n")

### chapter8: 字符输入/输出和输入验证
- 单字符IO:getchar()和putchar()
> 每次只处理一个字符，
- 缓冲输入、无缓冲输入
> 把若干个字符作为一个块输入要提高效率，无缓冲输入在游戏等立刻执行情况下有有用武之地
> 缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中
> 行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区
- 文件结尾
> 通常有两种方法，一种是在文件结尾标记特殊字符（例如ctrl+z）,另外一种是计算文件的大小，当达到指定大小时，
> 就算达到了文件末尾，在c语言中，无论哪种情况，当使用getchar()读取文件监测到结尾时都将返回EOF(End OF File)
> scanf()函数监测到文件结尾时也返回EOF
- 重定向输入（<）
> 假设已经编译了echo_eof.c  程序，并把可执行版本放入一个名为echo_eof（或者在Windows系统中名为echo_eof.exe）的文件中。
> 运行该程 序，输入可执行文件名:echo_eof(windows为echo_eof.exe),该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入。
> 现在，假设你要用该程序处理名为words的文本文件:echo_eof < words (windows为echo_eof.exe<word)
- gcc编译源文件
> gcc echo.c --如果没有指定文件名称，则生成a.out(linux) 或 a.exe(windows)。
> gcc 源文件名 -o 目标文件名  ：gcc hello.c -o target/hello会在 target 目录下生成 hello.exe 文件(Linux 系统生成 hello 可执行文件)
- 重定向输出（>）
> 现在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。
> 然后，输入以下命令并开始输入:echo_eof>mywords 
> 通常会擦除该文件的内容，然后替换新的内容,
> 记住在每行的末尾单击Enter键，这样才能把缓冲区的内容发送给程序
- 组合重定向
> 现在，假设你希望制作一份mywords文件的副本，并命名为savewords。
> 只需输入以下命令即可:echo_eof < mywords > savewords
> 下面的命令也起作用，因为命令与重定向运算符的顺序无关：
> echo_eof > savewords < mywords
- 关于重定向运算符
> 重定向运算符连接一个可执行程序（包括标准操作系统命令）和一个数据文件，
> 不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序。
> 使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件
- 追加运算符（>> 运算符）
> 该运算符可以把数据添加到现有文件的末尾,而 | 运算符能把一个文件的输出连接到另一个文件的输入
- 小结
> prog>file:将输出重定向至文件， prog<file:将输入重定向至文件
> prog>file1<file2 prog<file2>file1  这两种形式都是把file2作为输入、file1作为输出
- 输入验证
> 简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值。
> 使用转换说明（如%d或%f）限制了可接受输入的字符类型，而getchar()和使用%c的scanf()接受所有的字符。
- 关键概念
> C程序把输入作为传入的字节流。getchar()函数把每个字符解释成一个字符编码。
> scanf()函数以同样的方式看待输入，但是根据转换说明，它可以把字符输入转换成数值。
> 许多操作系统都提供重定向，允许用文件代替键盘输入，用文件代替显示器输出。

```
  许多程序使用 getchar()逐字符读取输入。通常，系统使用行缓冲输入，
  即当用户按下 Enter 键后输入才被传送给程序。按下Enter键也传送了一个换
  行符，编程时要注意处理这个换行符。ANSI C把缓冲输入作为标准
  
  通过标准I/O包中的一系列函数，以统一的方式处理不同系统中的不同
  文件形式，是C语言的特性之一。getchar()和  scanf()函数也属于这一系列。
  当检测到文件结尾时，这两个函数都返回  EOF（被定义在stdio.h头文件中）

  混合使用 getchar()和 scanf()时，如果在调用 getchar()之前，scanf()在输
  入行留下一个换行符，会导致一些问题。不过，意识到这个问题就可以在程
  序中妥善处理。
```
### chapter9: 函数
- 递归
> 最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。
> 这种形式的递归被称为尾递归（tail recursion），因为递归调用在函数的末尾。
> 尾递归是最简单的递归形式，因为它相当于循环
> 递归如果循环次数过多则会创建大量的变量（呈指数倍增长）
- 编译多源文件代码程序
> unix: cc file1.c file2.c 生成a.out文件，同时还生成file1.o file2.o目标文件
> 如果只改变file1.c 则合并：cc file1.c file2.o
> linux:gcc file1.c fil2.c   gcc file1.c file2.o
> windows:类似linux
- 查找地址：&运算符
- 间接运算符*
> *间接运算符用于找寻存贮在内存地址上的值，也叫解应用运算符
> 变量名和内存地址一一对应，当编译后就不存在变量名了，只有内存地址，name表示地址上的值，&name表示内存地址，它只能赋值给指针变量
> var=*pr 找出指针变量指向的值（pr实际上市一个内存地址（指针），存储的是（指向的是）某个变量的内存地址，*pr实际上就是对其指向的内存地址求值）
- 指针
> 指向存储类型变量地址
> 假设一个指针的变量名为pr,则 pr=&name (把name变量的内存地址赋值给pr)
> 语句 pr=&name, val=*pr ==>val=name,由此可见,使用地址和间接运算符可以间接完成
> 赋值语句
- 小结：与指针相关的运算符
> 地址运算符&：给出变量的地址，间接运算符*：给出存储在指针指向地址上的值
- 指针的声明
> 声明指针时必须指定指针所指向的变量的类型，因为不同的类型占用不同的存储空间，另外，占用相同存储空间的不同类型的数据
> 他们的存储方式可能也大相径庭
> int *pi  char *ch  float *f,*g 
- 关于int *pc
> 类型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量是一个指针 int *pc,声明的意思是pc是一个指针
> *pc是int类型，pc是指向int类型变量的指针，所以说*是解应用运算符，pc的值是一个地址，大多数系统内部，指针由无符号整数表示，
> 但是指针并不是整数类型，它是一种新类型，ANSI C 专门为其提供了%p格式的转换说明
- 变量：名称、地址、值
> 编写程序时，可以认为变量有两个属性，名称和值，计算机编译和加载程序后，认为变量也有两个属性，地址和值，地址就是变量在计算机内部的值
> 在许多语言中，地址都归计算机内部管理，对程序员隐藏，然而在c中，可以通过&运算符访问地址，通过*运算符获得地址上的值，
> 例如&ban表示变量ban的地址，使用名称获得的是变量的值，例如：printf("%d\n",ban)打印ban的值，使用*运算符即可获得存储在地址上的值，如果path=&ban
> 则*path表示存储在&ban地址上的值
- 概括
> 普通变量把值作为基本量，把地址作为通过&运算符获得的派生量，指针变量把地址作为基本量，把值作为通过*运算符获得的派生量

### chapter10:数组和指针
- 数组
> 对于自动存储类别的数组（在函数内部声明的，不带static的），如果不初始化数组，数组元素和未初始化的普通变量一样，其中存储的都是垃圾值，
> 蜀国初始化部分数组，剩余的元素就会被初始化为0,如果初始化项多于数组个数，则会报错，其实可以省略方括号中的数组个数，让编译器自动匹配数组大小
> 根据初始化时的数据项数目
- 指定初始化器
> 可以初始化指定的数组元素，例如初始化最后一个元素
> int arr[6]=[0,0,0,0,0,216],现在可以这样：int arr[6]={[5]=216}
- 数组边界
> 编译器不会报错，关于数组的边界需要程序员自己注意（编译器不检查，程序运行的更快）
> 数组的大小最好使用符号常量表示，这样做能确保整个程序中的数组大小始终一致
- 变长数组
> C99允许这么定义数组 int m=5 int arrs[m];此时arrs称为变长数组，它有一些限制，比如声明的时候不能初始化
- 多维数组
> float[5][12]
> 初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，
> 初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。
> 后面没有值初始化的元素被统一初始化为0
- 其他多维数组
> int box[10][20][30] 
> 可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表
> 例如，把上面声明的三维数组box想象成由10个二维数组（每个二维数组都是20行30列）堆叠起来。
> 还有一种理解box的方法是，把box看作数组的数组。也就是说，box内 含10个元素，
> 每个元素是内含20个元素的数组，这20个数组元素中的每个元素是内含30个元素的数组。
> 或者，可以简单地根据所需的下标值去理解数组
> 通常，处理三维数组要使用3重嵌套循环，处理四维数组要使用4重嵌套循环。对于其他多维数组，以此类推
- 指针和数组
> 指针再某种程度上把程序员想要表达的指令以更接近机器的方式表达，数组表示法其实是在变相的使用指针
> 例如：数组名是数组首元素的地址=》arrs==&arrs[0] (&是地址运算符)，他们都是常量，在运行过程中不会改变
> 可以把他们赋值给指针变量，然后可以修改指针变量的值
```
  指针的值是它所指向对象的地址，地址的表示方式依赖于计算机内部的硬件，许多计算机都是按字节编址
  意思是内存中的每个字节都按照顺序编号，这里，一个较大的对象的地址（如double类型的变量）通常是该对象第一个字节的地址
  在指针前面加上*运算符可以得到该指针所指向对象的值
  指针加1，只针对额值递增他所指向类型的大小（以字节为单位）
  下面的等式体现了c语言的灵活性：
    dates+2==&date[2] //相同的地址
    *(dates+2)=dates[2] //相同的值
  以上关系表明数组和指针关系十分密切，可以使用指针标识数组的元素和获取元素的值，从本质上看，同一个对象有两种表示法
  实际上C语言标准在描述数组表示法时确实借助了指针，也就是说定义arr[n]的意思是*(arr+n),可以认为*(arr+n)的意思是：
  到内存的arr位置，然后异动n个单元，检索存储在那里的值
  *(date3+2)==》dates的第三个元素
  *dates+2 dates的第一个元素的值+2  
```
- 函数、数组和指针
> 编写一个处理数组的函数，返回数组中所有元素之和：
> total=sum(members);//也许你会这样调用函数
```
  那么，该函数的原型是什么？记住，数组名是该数组首元素的地址，所以members实际上是一个存储int类型值的地址
  应该把它赋值给指针形式参数，即参数应该是一个指向int的指针
    int sum(int *arr);//对应的函数原型
  但是上面sum(members)只是获得了,数组首元素的地址，并未包含数组元素个数信息
    int sum(int *arr){
      int i;int total=0;
      for(i=0;i<10;i++){
        total+=arr[i];//这里arr[i]与*(arr+i)相同
      }
    }  
  既然可以使用指针表示数组名，也可以使用数组名表示指针：
  int sum(int *arr,int m)
  上方的形参表示数组的地址和数据类型，第二个参数表示原数组个数  
  在函数的形参中表示中，可以在函数原型表示上，使用int arr[]代替int *arr
  int sum(int[] arr,int m)//数组名是该数组首元素的地址，形参是一个与之匹配的指针或数组
  下面代码等价：
      int sum(int arr[],int m){}//arr是首位地址，可以赋给指针变量
      int sum(int *arr,int m){}//arr是一个指针
  
```
- 使用指针形参
> 函数处理数组，必须要知道何时开始何时结束，sum()函数使用一个指针表示数组开始，一个整数表示待处理数组个数
> 这并不是传递信息的唯一办法，还有一种方法是传递两个指针，第一个指针指明数组的开始处，第二个指针指明数组的结束处
- 指针表示法和数组表示法
> 处理数组的函数实际上使用指针作为参数，但是在编写这样的函数时，可以选择使用数组表示法还是指针表示法，
> 对于c语言，arr[i]和*(arr+i)这两个表达式都是等价的，无论arr是数组名还是指针变量，这两个表达式都没问题，但是只有是指针
> 变量时，才可以使用arr++这类表达式

- 指针操作
> 指针变量有8种基本的操作：
> 把一个地址赋值给指针  递增指针 递减指针 恢复为初始值 一个指针减去另一个指针 一个指针减去一个整数 解引用指针 获得指针地址
```
    赋值：可以把地址赋值给指针，例如使用数组名，带地址运算符&的变量名，另一个指针进行赋值，注意地址应该和指针类型兼容，不能把double类型的地址赋值给int类型的指针
    解引用：*运算符给出指针指向地址上存储的值，地址是内存中连续排列的大小单元，一般以字节为单位
    取址：和所有变量一样，指针变量也有自己的地址和值，对指针而言，&运算符给出指针本身的地址，指针变量本身表示该地址上的值
    指针与整数相加：整数与类型大小相乘，然后同指针地址相加：pt1+4==>urn[4],如果相加结果超出指针指向数组的范围，则计算结果为未定义的
    指针递增：递增指向数组元素的指针可以让指针指向数组的下一位元素相当于指针移动了该数据类型的字节数
    比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同的类型
    解引用未初始化的指针会有问题；int *pt1l  *pt1=5 会出问题，后面将5赋值给pt1指向的位置，但是pt1没有被初始化
        切记；创建一个指针变量时，系统只分配了存储指针本身的内存，并未分配存储数据的内存,因此在使用指针前，必须使用已分配的地址初始化它，
        例如可以使用一个现有的变量的地址初始化它（使用带指针形参的函数时，就属于这种情况）
            假设：int um[3];int *pt1,*pt2;//未初始化的指针
            有效：pt1++;pt2=pt1+2;pt2=um+1;
            无效：um++;pt2=pt2+pt1;pt2=urm+pt1
    基于这些有效的操作，c创建了数组指针，函数指针，指向指针的指针数组，指向函数的指针数组
    指针的第一个用法是在函数间传递信息（被调函数中改变主调函数的变量）
    指针的第二个用法是用在处理数组的函数中
```
- 保护数组中的数据
> 编写一个处理int类型的函数时，要选择是传递int类型的值还是传递指向int的指针，通常都是直接传递数值，只有在需要改变该数值的时候才会传递指针，数组别无选择
> 只能传递指针，因为这样做效率高，如果一个函数按值传递数组，则必须分配足够的空间来存储原数组的副本，然后把原数组的数据拷贝到新的数组中
> 如果把这个数组的地址传递给函数，让函数处理原数组则会效率更高，传递地址会导致一些问题，c通常都按照值传递数据，因为这样做可以保证数据的完整性，但是处理数组的函数
> 通常都会使用原始的数据,
- 对形式参数使用const
> 如果函数的意图不是修改数组中的内容，那么在函数的原型和定义中声明形式参数应该使用const,如果在函数中不小心使用指针更改了原始数据，编译器会捕获这个错误并生成错误信息
> 一般而言，如果编写的函数需要改变原始数组，在声明数组行参时不使用const,如果不需要改变，则应该使用const
- const的其他内容
> 可以创建const变量，const数组，const指针，和指向const的指针
> 无论是使用指针表示法还是使用数组表示法，都不允许pd修改它所指向的数据
```
  关于指针赋值和const需要注意的一些地方：
    1：把const的数据或非const数据的地址初始化为指向const的指针或为其赋值是合法的
      double rate[]={12.1,32,33.3};
      const double rates2[]={12.33,34.55,3445.33};
      const double *pc=rate;//有效
      pc=rates2;//有效
      pc=&rate[2];//有效
    2：只能把非const数据的地址赋值给普通指针
      double * ps2=rate;//有效
      ps2=rates2;//无效
      ps2=rate[2];//有效
    这个规则十分合理，否则通过指针就能改变const数组中的数据了
    C语言规定，使用非const标识符（如函数的形参）去修改const数据，如rates2,导致的结果是未定义的
    const可以声明并初始化一个不能指向别处的指针，关键是const的位置
    double rass[5]={12,12.33,23,44,4,6}
    double *const pcs=rass;//pcs指向数组的开始位置
    pcs=&rass[2];//不允许，因为该指针不能指向别处
    *pc=22.88;//ok，更改rass[0]的值
    可以用这种指针修改它所指向的值，但是他只能指向初始化的地址
    还可以在创建指针的时候使用两次const,该指针既不能改变它所指向的地址，也不能修改指向地址上的值
    double arrays[2]={12,23.44}
    const double *const pss=arrays;
    pss=&arrays[2];//不允许
    *pss=22.44;//不允许    
```
- 指针和多维数组
> 指针和多维数组有什么关系，处理多维数组的函数要用到指针
```
  * * * *
  * * * *
  假设有如下声明：int zippo[4][2];//内含int数组的数组
  然后数组的名称zippo是该数组首元素的地址，在本例中，zippo首元素是一个内涵两个int值的数组,所以zippo是这个内涵两个int值的数组的地址
  我们从指针进一步分析：
    因为zippo是数组首元素的地址，在本例中，所以zippo的值和&zippo[0]的值相同，而zippo[0]本身是一个内含两个int值的数组
    所以zippo[0]的值是和他内部的首元素（一个int值）的地址相同，简而言之：zippo是一个占用两个int大小的数组的地址，zippo[0]是一个占用一个int大小的整数的地址
    由于这个整数的地址和内含两个整数的数组的地址都开始于同一位置，所以zippo和zippo[0]的值相同
  
  给指针或地址+1，会增加对应类型大小的数值，在这方面zippo和zippo[0]不同，zippo的但愿是两个整形的数组，而zippo[0]的单元是int类型整数，所以zippo+1于zippo[0]+1的值不同，
  
  解引用一个指针（在指针前面使用*运算符）或在数组名后面使用带下标的[]运算，得到引用对象代表队额值，因为zippo[0]是该数组的首元素
  （zipp0[0][0]）的地址，所以*zippo[0]，代表存储在zippo[0][0]地址上的值，于此类似，*zippo代表该数组首元素（zippo[0]）的值，但是因为
  zippo[0]本身是一个int类型值的地址，该值的地址是：&zippo[0][0],所以*zippo==&zippo[0][0],==>**zippo==*&zippo[0][0]==zippo[0][0]
  由上可以得知，**zippo==int值，所以zippo是地址的地址，需要解引用两次才能得到原始int值
    地址的地址或者指针的指针就是双重间接的例子，详情见例子zippo1.c
```
- 数组指针理解
> 在我们的系统中，int是4字节，zippo[0]指向一个4字节的数据对象，zippo[0]+1,其值加4
> 数组名zippo是一个内含2个int类型值的数组的地址，所以zippo指向一个8字节的数据对象，zippo+1,
> 它所指向的地址加8个字节
- 取值
> zippo[0]和*zippo完全相同，然后对二维数组名解引用两次，得到存储在数组中的值，使用两个间接运算符* 或者使用两队方括号，或者一个*和【】都可以
- 指向多维数组的指针
> 如何编写一个指针变量pz指向一个二维数组如zippo,在编写处理类似zippo这样的二维数组的时候会用到这样的指针，
> 把指针声明为执向int的类型还不够，因为指向int的只能和zippo[0]的相匹配，说明该指针指向一个int类型的值，但是zippo是他的首元素地址，该元素是一个包含
> 两个int类型的一维数组，因此pz必须指向一个包含两个int类型值的数组，而不是指向一个int类型值，其声明如下：
```
  int (*pz)[2]; pz指向一个内含两个int类型值的数组
  以上代码将pz声明为指向一个数组的指针，该数组内含两个int类型的值，为什么使用（），因为【】优先级高于*
  考虑如下声明：
    int *ps[2];//ps是一个内含两个指针元素的数组，每个元素都指向int的指针
      由于【】优先级高于*，先于ps结合，所以ps成为一个内含两个元素的数组，然后*表示ps数组内含两个指针 ，最后int表示ps数组中的指针都指向int类型的值
      前方的则表示：*先于pz结合，因此声明的是一个指向数组（内含两个int类型的值）的指针
```
- 指针的兼容性
> 指针之间的赋值比数值类型值之间的赋值要严格的多，数据之间可以是使用类型转换，把int赋值给double类型变量
> 但是指针之间是不可以这样做的：如下：
```
  int n=5;
  double x;
  int *px=&n;
  double  *db=&x;
  x=n;//隐式类型转换
  db=px;//编译器错误
  更复杂的类型也是如此：
  int *pt;
  int(*pa)[3];
  int arr1[2][3];
  int arr2[3][2];
  int **p2;//一个指向指针的指针
  有如下语句
  pt=&arr1[0][0];//都是指向int的指针
  pt=arr1[0];//都是指向int的指针
  pt=arr1;//无效  pt 指向一个 int类型值，而ar1指向一个内含3和int类型元素的数组
  pa=arr1;//都是指向内含三个int值数组的指针
  pa=arr2;//无效 pa指向一个内含2个int类型元素的数组 arr2指向内含3个int类型元素的数组
  p2=&pt  ;//指针的指针
  *p2=arr2[0];都是指向int的指针
  p2=arr2;//无效 p2指向的指针指向int,arr2指向的指针是一个数组，类型不兼容
```
- 多重解引用让人费解
> 详情请见练习dereference.c
- C const和C++ const
```
  C和C++中const的用法很相似，但是并不完全相同。区别之一是，
  C++允许在声明数组大小时使用const整数，而C却不允许。区别之二是，
  C++的指针赋值检查更严格：
  const int y;
  const int * p2 = &y;
  int * p1;
  p1 = p2; // C++中不允许这样做，但是C可能只给出警告
  C++不允许把const指针赋给非const指针。而C则允许这样做，但是如果
  通过p1更改y，其行为是未定义的。  
```
- 函数和多维数组
> 要编写处理二维数组的函数，先要正确理解指针才能写出声明函数的形参
- 多维数组指针表示法
> 一般而言，声明一个指向N维数组的指针时，只能省略最左边的一堆方括号中的值：
> int sum4(int arr[][2][3][4]),因为第一队方括号只用来表明这是一个指针，而其他方括号用来
> 描述指针所指向数据对象的类型，下面的声明与上面的等价：
> int sum5(int (*arr)[2][3][4]),arr时一个指针，指向一个2*3*4的int数组
- 变长数组(VLA==>variable length array)
> C规定，数组的维数必须是常量，不能用变量代替cols, C99新增了变长数组，允许使用变量表示数组的维度
> int x=5;int y=4; int array[x][y]
```
  变长数组有一些限制：变长数组必须是自动存储类型，这意味着无论再函数中声明还是作为函数形参使用
  都不能使用static/extern存储类别说明符，而且不能在声明中初始化他们
  注意，变长数组不能改变大小，这里的变指的是创建数组时可以使用变量指定数组的维度，一旦创建了变长数组，
  他的大小则保持不变：
  int sums(int rows,int cols,int arr[rows][cols])//注意参数顺序，因为存在先后关系，不能先声明arr
  让然也可以省略形参名==》int sums(int,int,int arr[*][*]);//省略维度形参名，使用星号代替
  在函数定义的形参列表中声明的变长数组并未实际创建数组，和传统的语法类似，变长数组名实际上就是一个指针
  这说明带变长数组形参的函数实际上是在原数组中处理数组，因此可以修改传入的数组
  int thing [10][6]
  toset(10,6,thing)==>这里的thing指针就是传递函数形参的指针，可以根须函数形参来修改原数组
  int toset(int,int,int arr[*][*]) arr表示指向thing[0]的指针（thing是一个指针，指向长度为10的数组（内含6个int值））
  因为ar和thing都是指向thing[0]的指针，ar[0][0]与thing[0][0]访问的数据位置相同
```
- const和数组大小
> C99/C11 标准允许在声明变长数组时使用 const 变量。
> 所以该数组的定义必须是声明在块中的自动存储类别数组。
> 变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大 小。
> 普通 C数组都是静态内存分配，即在编译时确定数组的大小。
> 由于数组 大小是常量，所以编译器在编译时就知道了。
- 复合字面量
> 类似int字面量 4 ，double字面量2.33，char字面量'Y',字符串字面量“element”
> 数组也有字面量，普通声明数组 int div[2]={2,3},字面量表示为：（int[2]）{2,3}
> 其中：去掉声明中的数组名，留下的int[2]就是复合字面量的类型名
```
  初始化有数组名的数组时可以省略数组的大小，复合字面量也可以省略数组的大小，编译器会自动计算数组当前元素的个数
  int arr[]={2,4}
  (int[]){2.4}
  以为复合字面量是匿名的，所有不能先创建然后使用它，必须创建的同事使用它：
  int * pt1;
  pt1=(int[]){2,3}
  与有数组名的数组类似，复合字面量的类型名称也代表首元素的地址，所以可以把他赋值给
  指向int的指针没然后使用该指针，例如*pt1=2,pt1[1]=3
  还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数
  例如： total=sum((int[]){2,3});这样使用的好处是：把信息传入函数前不必创建数组
  还可以类似用于二维数组或多维数组: int(*pt2)[4],pt2=(int[2][4]{{1,2,3,4},{2,3,4,5}})
```
- 关键概念
```
  1:C把数组名解释为该数组首元素的地址，换言之，数组名与指向该数组首元素的指针等价，概括的说，数组与指针的关系十分密切
  如果ar是一个数组，那么ar[i]与*(ar+1)等价
  2:对于C语言而言，不能把整个数组作为参数传递给函数，但是可以传递数组的地址  ，然后函数可以使用传入的地址操控原始数组，如果
  没有修改原始数组的意图，则函数的形参应该使用const关键字修饰，在被调函数中可以使用数组表示法或者指针表示法，无论使用哪一种表示法，实际上使用的都是指针变量
  3:指针加上一个整数或者递增指针，指针的值所指向的对象的大小为单位改变，也就是说，如果pd指向一个数组的8字节都变了类型的值那么pd加一意味着，其值加上8，以便指向该数组的下一个元素
  4：C语言传递多维数组的方式是把数组名（即数组的地址）传递给类型匹配的指针形参，声明这样的指针形参需要指定所有的数组维度，除了第一个维度
    传递的第一个维度通常作为函数的第二个参数： int sum(int arr[][12],int rows)==>int sum(int (*arr)[12],int rows)
  5:变长数组 int sums(int rows,int cols,int arr[rows][cols])  
```

### chapter11: 字符串和字符串函数
- 表示字符串和字符串I/O
> 字符串是以空字符（\0）结尾的char类型数组，由于字符串十分常用，所以C提供了许多专门用于处理字符串的函数
```
  1:字符串字面量：用双引号括起来的，也叫字符串常量，双引号中的而字符和编译器自动加入末尾的\0字符，都作为字符串存储在内存中
    如果字符串字面量之间没有间隔，或者用空白字符分割，C会视其为串联起来的字符串字面量
    如果要在字符串内部使用双引号，则需要在前面添加一个反斜杠
      “\"hasdasdada\"” ==>"hasdasdada"
    字符串常量属于静态存储类别（static storage class）,这说明如果在函数中使用字符串字面量，该字符串只会被存储一次 
    在整个程序的生命期内存在，用双引号括起来的内容被视为指向该字符串存储位置的指针
    类似于数组名作为指向数组位置的指针
  2：字符串数组和初始化
    定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足够空间的数组储存字符串
    const char m1[10]={'s','p','r','i','n','g','\0','','',''}
    注意最后的空字符。没有这个空字符，这就不是一个字符串，而是一个字符数组,
    在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为了容纳空字符）
    所有未被使用的元素都被自动初始化为0（这里的0指的是char形式的空字符，不是数字字符0）
    const char at[]="xahaduahsdi asdsd.";让编译器确定字符数组大小
    char car[10]="Tata";==>car=&car[0] *car='T' *(car+1)='a'
  3:指针表示法创建字符串  
```
- 指针和字符串
> 字符串的绝大部分操作是通过指针完成的
- 字符串输入
> 如果想把一个字符串读入程序，首先需要预留存储该字符串的空间，然后用输入函数获取该字符串
- gets()函数
> 读取字符串时，scanf()和转换说明%s只能读取一个单词，gets()用于整行输入读取，知道遇到换行符，然后丢弃换行符，存储其余字符，并在末尾加上
> 空字符使其成为一个字符串，经常和puts函数配合使用（用于显示字符串，并在末尾加上换行符）,过去，有些人通过系统编程，利用gets()插入和运行一些破坏系统安全的代码。
- gets()函数的替代品
> 通常fgets()替代get(),gets_s()也可以替代gets(),
```
  1:fgets()与fputs()函数：
    fgets函数的第二个参数表示读入字符的最大数量，如果为n,表示最多读取n-1个，同时加上一个换行符，专门用于处理文件输入，
    第三个参数指明要读入的文件，如果从键盘输入数据则以stdin(标准输入)作为参数，该标识符定义在stdio.h中
    fputs函数用于输出字符，第二个参数指明他要写入的文件，如果是显示在计算机屏幕上，则使用stdout(标准输出)作为参数
    fputs(words,stdout);fputs()函数返回指向 char的指针。如果一切进行顺利，该函数返回的地
    址与传入的第 1 个参数相同，但是，如果函数读到文件结尾，它将返回一个
    特殊的指针：空指针（null pointer）。该指针保证不会指向有效的数据，所
    以可用于标识这种特殊情况。在代码中，可以用数字0来代替，不过在C语
    言中用宏NULL来代替更常见（如果在读入数据时出现某些错误，该函数也
    返回NULL） 
```
- 空字符和空指针
> 空字符（'\0'）适用于标记c字符串末尾的字符，其对应的字符编码是0,其他字符的编码不可能是0，所以不可能是字符串的一部分
> 空指针有一个值，该值不会与任何数据的有效地址对应
> 空字符是整数类型，而空指针是指针类型。两者有时容易混淆的原因 是：
> 它们都可以用数值0来表示。但是，从概念上看，两者是不同类型的0。 
> 另外，空字符是一个字符，占1字节；而空指针是一个地址，通常占4字节。
- gets_s()函数
> C11新增的gets_s()函数（可选）和fgets()类似，用一个参数限制读入的字符数。
> 假设把程序清单11.9中的fgets()换成gets_s()，其他内容不变，
> 那么下面的代码将把一行输入中的前9个字符读入words数组中，假设末尾有换行符
```
  gets_s(words, STLEN);
  gets_s()与fgets()的区别如下。
  gets_s()只从标准输入中读取数据，所以不需要第3个参数。
  如果gets_s()读到换行符，会丢弃它而不是储存它。
    如果gets_s()读到最大字符数都没有读到换行符，会执行以下几步。首
    先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直至读到换
    行符或文件结尾，然后返回空指针。接着，调用依赖实现的“处理函数”（或
    你选择的其他函数），可能会中止或退出程序
  只要输入行未超过最大字符数，gets_s()和gets()几乎一
  样，完全可以用gets_s()替换gets()。
  
  我们来比较一下 gets()、fgets()和 gets_s()的适用性。如果目标存储区装
  得下输入行，3 个函数都没问题。但是fgets()会保留输入末尾的换行符作为
  字符串的一部分，要编写额外的代码将其替换成空字符
  
  如果输入行太长会怎样？使用gets()不安全，它会擦写现有数据，存在
  安全隐患。gets_s()函数很安全，但是，如果并不希望程序中止或退出，就
  要知道如何编写特殊的“处理函数”。另外，如果打算让程序继续运行，
  gets_s()会丢弃该输入行的其余字符，无论你是否需要。由此可见，当输入
  太长，超过数组可容纳的字符数时，fgets()函数最容易使用，而且可以选择
  不同的处理方式。如果要让程序继续使用输入行中超出的字符，可以参考程
  序清单fget2中的处理方法。如果想丢弃输入行的超出字符，可以参考程序清
  单fgets3中的处理方法。
  所以，当输入与预期不符时，gets_s()完全没有fgets()函数方便、灵活。
  也许这也是gets_s()只作为C库的可选扩展的原因之一。鉴于此，fgets()通常
  是处理类似情况的最佳选择
  
```
- scanf()函数
> scanf函数更像是“获取单词函数”，而不是获取字符串函数,以第一个非空白字符作为字符串的开始，以下一个空白符作为字符串的结束,
> scanf返回一个整数值，等于scanf成功读取的项数或者文件结尾EOF
```
_：表示空格字符
  输入语句                  原输入序列           name中的内容        剩余输入序列
  scanf("%s",name)      Fleebert_Hup         Fleebert           _Hup
  scanf("%5s",name)     Fleebert_Hup         Fleeb              ert_Hup
  scanf("%5s",name)     Ann_Ular             Ann                _Ular
  scanf()和gets()类似，也存在一些潜在的缺点，如果输入行的内容过长，scanf也会导致数据溢出，不过在%s准换说明中使用字段宽度可以防止溢出
```
- 字符串输出
> C有三个标准库函数用于打印字符串：puts(),fputs(),printf()
- puts()函数
> 把字符串地址作为参数传递即可,puts把空白符组为结束符，所以字符数组要带上‘\0’,字符串字面量会自动截断并添加空白符结尾
- fputs()函数
> fputs()函数是puts()针对文件的定制版本
> fputs的第二个参数指明要写入数据的文件，如果打印在显示器，则使用标准输出作为参数（stdout）
> 与puts不同，fputs不会在输出的末尾添加换行符
> 注意：gets()丢弃输入中的换行符，puts在输出中添加换行符，fgets()保留输入中的换行符，fputs不在输出中添加换行符
> puts()应与gets()配对使用，fputs()应与fgets()配对使用
- printf()函数
> printf()也把字符串的地址作为参数,printf()不会自动在每个字符串末尾加上一个换行符
- 自定义输入输出函数
> 不一定非要使用C库中的标准函数，也可以自定义自己的函数
- 字符串函数
> c库提供了很多处理字符串的函数，ansi c把这些函数的原型放在string.h头文件中，常用的有strlen(),strcat(),strcmp(),strncmp(),strcpy(),strncpy(),
> sprintf(),
- strlen()函数
> 统计字符串的长度
- strcat()函数
> 用于拼接字符串，接受两个字符串作为参数，把第二个字符串的备份附加到第一个字符串末尾，并把拼接后的字符串作为第一个字符串，第二个字符串不变
> 返回第一个参数，即凭借后第一个字符串的地址
- strncat()函数
> strcat()无法检查第一个数组是否能够容纳第二个字符串，如果分配给第一个数组的空间不够大，多出来的字符溢出到相邻存储单元时就会出问题，
> strncat(str1,str2,int addnum),addnum代表要添加的个数，如果str2中有遇到空字符，还没超过添加个数则挺住添加，如果正好或大约addnum
> 则只添加addnum个，并且在后面加上空字符，任何情况，都是以空字符结尾，要求str1要足够大以容纳这些
> strcat()和 gets()类似，也会导致缓冲区溢出,gets()造成的安全隐患来自于使用该程序的人，而strcat()暴露的问题是那些粗心的程序员造成的
> 无法控制用户会进行什么操作，但是，可以控制你的程序做什么。C语言相信程序员，
> 因此程序员有责任确保strcat()的使用安全
- strcmp()函数
> 字符串比较函数,ansi c 规定，在字母表中如果第一个字符串在第二个字符串前面，strcmp返回一个负数，如果两个字符串相同，返回0，如果第一个字符串在第二个字符串后面则返回整数
> 实现大概是用前面-后面得出差值
- strncmp()函数
> 比较指定长度的字符
- strcpy()和strncpy()函数
> 前面提到过，如果pts1和pts2都是指向字符串的指针，那么下面语句拷贝的是字符串的地址而不是字符串本身
> pts2 = pts1;如果希望拷贝整个字符串，要使用strcpy()函数
> strcpy()接受两个字符串指针作为参数，可以把指向源字符串的第2个指针声明为指针、数组名或字符串常量；
> 而指向源字符串副本的第1个 指针应指向一个数据对象（如，数组），且该对象有足够的空间储存源字符 串的副本。
> 记住，声明数组将分配储存数据的空间，而声明指针只分配储存一个地址的空间。
```
  strcpy()的返回类型是 char *，
  该函数返回的是第 1个参数的值，即一个字符的地址。第二，第 1 个参数不
  必指向数组的开始。这个属性可用于拷贝数组的一部分

```
- strncpy()
> strcpy()和  strcat()都有同样的问题，它们都不能检查目标空间是否能容纳源字符串的副本,拷贝字符串用 strncpy()更安全
> 该函数的第 3 个参数指明可拷贝的最大字符数,
- sprintf()
> sprintf()函数声明在stdio.h中，而不是在string.h中。该函数和printf()类 似，
> 但是它是把数据写入字符串，而不是打印在显示器上。因此，该函数可以把多个元素组合成一个字符串。
> sprintf()的第1个参数是目标字符串的地址。其余参数和printf()相同，即格式字符串和待写入项的列表。
> sprintf()函数获取输入，并将其格式化为标准形式，然后把格式化后的字符串存储在第一个参数内
- 其他字符串函数
```
1:char *strcpy(char* s1,const char * restrict s2);//把s2指向的字符串包括空字符拷贝至s1指向的位置，返回s1
2:char *strncpy(char *s1,const char *s2,size_t n);//将s2指向的字符拷贝至s1指定的位置，拷贝的字符数不超过n,返回s1,
3:char *strcat(char *s1,const char *s2);//将s2拷贝到s1指向的字符串末尾，覆盖空字符，返回s1
4:char *strncat(char *s1,const char *s2,size_t n);//将s1添加至s2末尾，覆盖末尾空字符，并添加一个空字符，该函数返回s1
5:int strcmp(const char *s1,const char *s2);//比较字符串，s1-s2,s1,s2是在机器中的编码序列
6:int strncmp(const char *s1,const char *s2,size_t n);//与上方类似，比较前n个或者遇到空字符停止比较
7:char *strchr(const char *s,int c);//如果s字符串包含字符c,该函数返回指向s的指针，未找到返回空指针
8:char *strbpbrk(const char* s1,const char* s2);//如果s1包含s2中的任意字符，则返回指向s1位置的指针
9:char *strstr(const char *s1,const char* s2);//返回指向s1字符串中s2字符串出现的首位置，如果没有找到s2,返回空指针
10:char * strrchr(const char *s,int c);//该函数返回s字符串中c字符的最后一次出现的位置（末尾的空字符也是字符串的一部分，所以在查找范围内）。果未找到c字符，则返回空指针
11:size_t strlen(const char* s);//返回s字符串中的字符数，不包括末尾的空字符
关键字restrict该关键字限制了函数参数的用法。例如，不能把字符串拷贝给本身
size_t类型是sizeof运算符返回的类型。C规定sizeof运
算符返回一个整数类型，但是并未指定是哪种整数类型，所以size_t在一个
系统中可以是unsigned int，而在另一个系统中可以是 unsigned long。string.h
头文件针对特定系统定义了 size_t，或者参考其他有 size_t定义的头文件
```
-ctype.h字符函数和字符串
> 这些函数用来处理字符，和字符串有一定的关系
- 命令行参数
> $fuccess.exe -r Color
> 一个c程序可以读取并使用这些附加项
```
  1:c编译器允许mian()函数没有参数或者有两个参数（一些实现允许main()有更多参数，属于对标准的扩展），main()有两个参数时
  第一个参数是命令行中的字符串数量，系统用空格表示一个字符串的结束和下一个字符串的开始，程序把命令行字符串存储在内存中，每个字符串的地址存储在指针数组中，
  而该数组的地址则被存在main的第二个参数中，本质上来说，第二个参数是数组的指针，值就是一个地址值，指向数组的第一个地址，然后数组的第一个位置上的值指向内存中第一个参数值的地址
  我们打印的时候其实%s其实就是打印这个参数值的地址，
  char *arg[]与char **arg等价，即char是指针的指针
```
- 把字符串转化为数字
> printf()和sprintf()函数使用%d,scanf()把输入字符串转换为数字，比如函数atoi(),把字符串转换为整数，atio()表示只把开头的整数字符串数字换成整数，
> 如果命令行参数不是数字，atoi()函数返回0。然而C标准规定，这种情况下的行为是未定义的。
> 因此，使用有错误检测功能的strtol()函数（马上介绍）会更安全。atof(),atol(),strtol(),strtoul(),strtod(),
- 关键概念
> 字符串，无论是由字符数组，指针还是字符串常量标识，都存储为包含字符编码的一系列字节，并以空字符串结尾，C提供库函数处理字符串，查找字符串并分析他们，
> 需要牢记，应该使用strcmp()来代替关系运算符，当比较字符串时，应当使用strcpy()或strncpy()代替赋值运算符把字符串赋值给字符数组
- 小结
```
  C字符串是一些列char类型的字符，以空字符('\0')结尾,字符串可以存储在字符数组中，字符串还可以用字符串常量来表示
  里面都是字符，包括在双引号中（空字符除外），编译器提供空字符，因此“yoy”被存储为4个字符，y.o.y.\0,strlen()函数
  可以统计字符的长度，空字符不计算在内，
  
  字符串常量也叫做字符量--字面量，可以用于初始化字符数组，为了容纳末尾的空字符，数组大小应至少比字符串长度多1，也可以使用字符串常量
  初始化指向char的指针
  
  函数使用指向字符串首字符的指针来表示待处理的字符串，通常对应的实际参数是数组名，指针变量或者字符串字面量，无论是哪种情况，传递的都是首字符的地址，
  一般而言，没必要传递字符串的长度，因为函数可以使用末尾的空字符来确定字符串的结束
  
  fgets()函数获取一行输入，puts和fputs函数显示一行输出，他们都是stdio.h头文件中得函数，用于代替已被启用得gets()
  c库中有许多处理字符串得函数，在ansc中，他们声明在string.h文件中，c库还有很多处理字符函数，声明在ctype.h头文件中
  
  给main函数提供两个合适得形式参数，可以让程序访问命令行参数，第一个参数通常是int类型得arg，其值是命令行单词得数量，第二个参数
  通常是一个指向数组得指针，数组内含指向char的指针，每个指向char的指针都指向命令行参数的第一个字符串地址
  
  atoi(),atol(),atof()把字符串形式的数字转换成相应的数字，strtol(),strtoul(),strtod()函数把字符串形式的数字转换为相应的数字类型
  
```
### chapter12: 存储类别，链接和内存管理
-本章要点
> 关键字：auto extern static register const volatile restricted _Thread_local _Atomic
> 函数：rand() srand() time() malloc() calloc() free()
> 如何确定变量的作用域（可见的范围）和声明周期（它存在多长时间），
> 程序员通过 C的内存管理系统指定变量的作用域和生命期，实现对程序的控制
> 合理使用内存储存数据是设计程序的一个要点
- 存储类别
> 从硬件方面来看，被存储的每个值都占用一定的物理内存，C语言把这样的一块内存称为对象
> 从软件方面来看，程序需要一种方法访问对象，可以通过声明变量来完成：int entity=3
> 该声明创建了一个名为entity的标识符，标识符是一个名称，可以用来指定特定对象的内容
> 这里entity标识符即是软件指定硬件内存中对象的方式，该声明还提供了存储在对象的值
```
  一般而言，那些指定对象的表达式被称为左值，（指定内存位置上的内容）
  如果可以使用左值改变对象中的值，该左值就是一个可修改的左值
  
  可以用存储期描述对象，所谓的存储期是指对象在内存中保留了多长时间，标识符用于访问对象，可以使用作用域和链接描述标识符，
  表明程序的哪些部分可以使用它
  
```
- 作用域
> 一个C变量的作用域可以是快作用域，函数作用域，函数原型作用域，或者文件作用域
> 函数的形参也属于函数的块级,函数作用域仅用于goto语句的标签，这意味着即使一个标签首次出现在函数内层
> 块中，它的作用域也延申至整个函数，如果在两个块中使用相同的标签会很混乱，标签的函数作用域防止了这样的事情发生。
> 原型作用域的范围是从形参定义处原型声明结束，只有在变长数组声明中，前面的形参名称才需要对应
> 变量的定义在函数的外面，具有文件的作用域（file SCOPE）,由于这样的变量可以用于多个函数，所以文件作用域变量也称为全局变量
- 翻译单元与文件
> 描述一个具有文件作用域的变量时，它的实际可见范围
> 是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个
> 翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件
- 链接
> C语言有3中链接属性：外部链接，内部链接，无链接
> 具有块作用域，函数作用域，函数原型作用域的变量都是无链接变量，这意味着这些变量属于他们定义的块，函数或者原型私有，具有文件作用域的变量
> 可以是外部链接或者是内部链接，外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用
```
  如何知道文件作用域变量是内部链接还是外部链接？可以查看外部定义中是否使用了存储类别说明符static
  int age=5;//文件作用域，外部链接
  static int price=4;文件作用域，内部链接
  该文件和同一程序中的额其他文件都可以使用变量age,但是变量price属于文件私有，该文件中的任何函数都可以使用它
```
- 存储期
> 作用域和链接描述了描述了标识符的可见性,存储期描述了通过这些标识符访问的对象的生命周期，c对象有四种存储期：静态存储期，线程存储期，自动存储期，
> 动态分配存储期
- 5种存储类别
```
  存储类别        存储期         作用域         链接          声明方式
  自动           自动           块            无            块内
  寄存器         自动           块            无            块内，使用关键字register
  静态外部链接    静态           文件           外部          所有函数外
  静态内部链接    静态           文件           内部          所有函数外，使用关键字static
  静态无链接     静态            块            无            块内，使用关键字static    
```
- 自动变量
> 自动存储类别的变量具有自动存储期，块作用域，且无链接，默认情况下，声明在块或函数头种的任何变量都呼吁自动存储类别，可用auto修饰变量
> 属于存储类别说明符号,块作用域和无链接意味着：只有在变量定义所在的块中，才能通过变量名访问对象，变量具有自动存储类别意味着，程序在进入该变量声明所在的块
> 时，变量存在，程序退出块时，变量消失，原本该变量占用的内存位置现在可做他用
> 
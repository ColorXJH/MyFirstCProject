## C Primer Plus Six Edition
### chapter1:初识C语言
- 目标代码、可执行文件和库
> 将源代码编译成可执行文件:源代码经过编译器编译为目标代，链接器将目标代码，启动代码以及库代码合成一个文件，即可执行文件，被计算机识别执行
> 编译器会创建一个与源代码基本名称相同的目标代码文件，扩展名为.o,一旦连接器生成了可执行文件就会删除目标代码文件，如果源代码文件有多个，则会保留目标代码文件

- 可移植性
> 完美的可移植性程序是指，其源代码无需修改的情况下就能在不同的计算机系统中成功的编译的程序

- 源代码、目标代码、可执行文件的区别
> 源代码文件包含程序员使用的任何语言编写的代码，目标代码文件包含及其语言代码，他不是完整的程序代码
> 而可执行文件包含组成可执行文件的完整机器语言代码

- 编程的7个步骤
> 定义程序目标 设计程序 编写程序 编译程序 运行程序 测试和调整程序 维护和修改程序

- 编译器的作用
> 编译器把源代码翻译成等价的及其语言代码（也叫目标代码）

- 链接器的作用
> 链接器把编译器翻译好的源代码以及库代码和启动代码组合起来，生成一个可执行程序
### chapter2:C语言概述
- 典型的C程序组成部分
  ```
    1:#include--->预处理指令
    2:int main(void)--->main()总是第一个被调用的函数
    3:function a()、function b()-->函数是C程序的构造块
        包含语句
        C语言中的6中语句:1：标号语句
                      2：复合语句
                      3：表达式语句
                      4：选择语句
                      5：迭代语句
                      6：跳转语句
        由关键字、标识符、运算符、数据组成
  ```
- C语言的基本模块是什么
> 他们都叫做函数

### chapter3:数据和C
- 计算机得存储方式
> 整数类型和浮点数类型 int long short unsigned signed void char float double _Bool _Complex _Imaginary
- unsigned与signed的区别
> unsigned用于表示无符号位数据，其将符号位化为二进制，用于非负值的场合，标识的数值比有符号位要大
> 同时signed强调使用有符号类型的意图：比如：short   short int    signed short int     signed short都表示的是同一种类型
> 其他辅助int类型的比如 long int / long long int
- 为什么使用多种整数类型
> C语言规定short占用的存储空间不能比int多，long占用的存储空间不能比int少
> 现代计算机最常见的设置是long long占用64位，long占用32位，short占用16位，int占用16、32位，依据计算机的自然字长而定
> l/L后缀表示long类型 ll/LL后缀表示long long类型，可以用作10，8，16这些不同进制的整数
> u/U后缀表示unsigned long long 例如：5ull 8llu 11ULL 7LLU
- 打印short、long、long long和unsigned类型
> 打印unsigned int类型使用%u,打印long类型的使用%ld,%lx表示以16进制格式打印long类型
> %lo表示以8进制格式打印long类型整数
> 对于short类型，%hd表示以10进制显示short类型整数，%ho表示以8进制显示，%hx
> h和l前缀都可以和u一起使用，用于表示无符号类型，例如：%lu表示打印unsigned long类型
> %llu,%lld分别表示无符号，有符号 long long类型数据
> 虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写(格式化响应类型数据时可以使用规则内的大小写切换)
> 例如L/l 0x/0X 
- 字符常量
> 在C语言中，用单引号括起来的单个字符被称为字符常量,双引号括起来的成为字符串
> 实际上，字符是以数值形式储存的，所以也可使用数字代码值来赋值
> char grade = 'A';==》char grade = 65
- 用八进制或十六进制表示字符
> beep='\a'==>beep='\007'
> beeps='\x010'==>beeps='\X10'
> 八进制使用反斜杠\+1-3位数字  十六进制使用\x+1-3位数字
- 有符号还是无符号
> 有些C编译器把char实现为有符号类型，这意味着char可表示的范围 
> 是-128～127。而有些C编译器把char实现为无符号类型，那么char可表示的 
> 范围是0～255。根据C90标准，C语言允许在关键字char前面使用signed或unsigned。
> 这样，无论编译器默认char是什么类型，signed  char表示有符号类型，
> 而unsigned  char表示无符号类型。这在用char类型处理小整数时很有用。
> 如果只用char处理字符，那么char前面无需使用任何修饰符。
- float,double,long double
> c语言规定float类型必须至少能够表示6位有效数字，且取值范围至少是10 -37 ～10 +37
> double类型浮点数为双精度数，他和float最小取值范围相同，但是至少必须能表示10位有效数字
> 一般情况下double占用64位而不是32位
- 浮点数常量
> 浮点型常量得基本形式是：有符号得数字（包括小数点），后面紧跟e/E,最后是一个有符号数表示10的指数
> -2.1E+12   2.334e3 2.3    2.   .3  .4e-6   
> 正号可以省略，可以没有小数点或指数部分，但不能同时省略两者，可以省略小数或整数部分，但不能同时省略2者
- 打印浮点数值
> %f 打赢十进制计数法浮点数  %e打印指数计数法浮点数  %a，%A打印16进制
> 打印long double需要使用%Lf %Le %La
- 浮点数的上溢和下溢
> 当计算导致数字过 大，超过当前类型能表达的范围时，就会发生上溢,
> C语言规定，在这种情况下会赋一个表示无穷大的特定值，而且printf()显示该值为inf或infinity
> float类型的数以指数和尾数部分来储存,假设存在一个最小的浮点数，即指数部分是最小值，其他的全部位数表示最小的位数值
> 现在将该值除以2，理论上这个操作会减小指数值，，但是指数值已经是最小的了，计算机只能将后面的尾数值向右位移一位，左边
> 空出一个二进制位，并丢弃最右边的一位二进制数，虽然得到了结果，
> 但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫 作下溢（underflow）
> 因此，把最小的正浮点数除以 2将得到一个低于正常的值。如果除以一个非常大的值，会导致所有的位都为0
- 复数和虚数类型
> 简而言之，C语言有三种复数类型：float_Complex,double_Complex,long double_Complex
> 例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部
> C语言的三种虚数类型：float_Imaginary,double_Imaginary,long double_Imaginary
- 小结：基本数据类型
```
 关键字：
  基本数据类型由11个关键字组成：int,long,char,short,unsigned,float,double,signed
  _Bool,_Complex,_Imaginary
 有符号整形：
  有符号整形可以表示正整数和负整数
  int->系统给定的基本整数类型，C语言规定int类型不小于16位
  short/short int->最大的short类型整数小于或等于最大的int类型整数，C语言规定short类型至少占16位
  long/long int->该类型表示的整数大于或等于最大的int类型整数,long至少占32位
  long long/long long int->该类型可表示的整数大于或等于最大的long型整数，long long至少占64位
  一般而言：long类型占用的内存比short大，int类型的宽度要么和long相同，要么和short相同，旧DOS系统的PC提供16位的
  short和int，以及32位的long；Windows 95系统提供16位的short以及32位的int和long
 无符号型：
  无符号整形只能表示正数和零，因此可表示的正整数要比有符号的大，在整形类型前面加上unsigned即可
 字符类型：
  可打印出来的符号都是字符，char类型表示一个字符需要占用一个字节内存，处于历史原因，一个字节通常是8位，但是如果要表示基本字符
  也可以是16位或者更大
  char->字符类型的关键字，有些编译器使用有符号的char,有些使用无符号的char,在需要是可以明确定义 signed unsigned
 布尔类型：
  true/false C语言使用1表示true,0表示false
  _Bool->布尔类型的关键字，是无符号的int类型，占用的空间只要能存储0、1即可
 实浮点类型：
  表示正浮点数和负浮点数，float->系统的基本浮点类型，可精确表示至少6位有效数字
  double->存储浮点数的范围更大，能表示比float类型更多的有效数字（至少10位，通常更多）和更大的指数
  long long->存储浮点数的范围可能比double更大，能表示比double更多的有效数字和更大的指数
 复数和虚数浮点数
  虚数类型是可选的，复数的实部和虚部类型都是基于实浮点数来构建的
  float_Complex,double_Complex,long double_Complex
  float_Imaginary,double_Imaganiary,long double_Imaginary  
  小结：如何声明简单变量
  1：选择需要的类型
  2：使用有效的字符给变量起一个名字
  3：按照以下格式声明：
    类型说明符 变量名；
    说明符由一个或多个关键字组成
      unsigned int errs;
  4：可以同时声明多个同类型变量，用逗号分割变量名，如下所示：
    char chs,intss,ans;
  5：在声明的同时还可以初始化变量：
     float mass=3.14E12
```
- 刷新输出
> printf()何时将输出发送到屏幕上？最初printf()语句将输出发送到一个叫做缓冲区（buffer）的
> 中间存储区域，然后缓冲区的内容再不断发送到屏幕上，C标准规定，缓冲区满，遇到换行字符串或者需要输入的时候
> 需要刷新缓冲区（从缓冲区把数据发送到屏幕或文件），还有一种方法就是使用刷新函数fflush()

### chapter4:字符串和格式化输入输出
- char类型数组和null字符
> c语言没有专门的存储字符串的变量类型，字符串都被存储在char类型的数组中，数组由连续的存储单元组成
> 数组的末尾若没有字符就是空字符，用\0表示，空字符不是0，他是非打印字符，其ascii码值是（或等价于）0
> c的字符串一定是以空字符结尾，这意味着数组容量必须至少比带存储的字符串中的字符数多1，
> 数组是同类型数据元素的有序序列

- 使用字符串
> 字符串常量"X",和字符常量‘X’不同：1：‘x’是基本数据类型char,"x"是派生类型（char数组）
> 2：“x”实际上是由两个字符组成：‘x’和‘\0’,以空字符作为字符串的结束
- strlen()函数
> sizeof运算符，他以字节为单位给出对象大小，strlen()给出字符串中的字符长度
> C99 和 C11 标准专门为 sizeof 运算符的返回类型添加 了%zd 转换说明，这对于strlen()同样适用。
> 对于早期的C，还要知道sizeof和strlen()返回的实际类型（通常是unsigned或unsigned long）
- sizeof
> 对于sizeof有时候使用括号，有时候不使用，使用预付取决于对象是类型还是特定量
> 当对象是类型时需要使用: sizeof(int),sizeof(char)
> 当对象是特定量时，可以不使用：sizeof name ;sizeof 6.28 
- 常量和c预处理器
> 变量，c语言可能会无意间修改了值，，对于常量，c提供了一个更好的方案，c预处理器，预处理器也可以用来定义常量，
> 只需在程序顶部添加一行 #define TEXTAREA 0.16,编译程序时，程序中所有的TEXTAREA都会被替换成0.015。
> 这一过程被 称为编译时替换（compile-time substitution）
> =>:#define name value
- const限定符
> 限定一个变量只读：const int mouth=12;
- printf()
> printf()与scanf()函数又称为输入输出函数，I/O函数
```
  转换说明            输出
  %A/%a             浮点数，十六进制和p计数法
  %c                单个字符
  %d                有符号十进制整数
  %e/%E             浮点数，e计数法
  %f                浮点数，十进制计数法
  %g/%G             根据值的不同，自动选择%f或%e,%e格式用于指数小于-4或者大于或等于精度时
  %i                有符号十进制整数（==%d）
  %o                无符号八进制整数
  %p                指针
  %s                字符串
  %u                无符号十进制整数
  %x/%X             无符号十六进制整数
  %%                打印一个百分号
```
- printf()的转换说明修饰符
> 在%和转换字符之间插入修饰符可修饰基本的转换说明
> 详情请见4.4.3
> 转换说明：%m.nf m指定字段宽度,n指定小数点精度
- 转换说明的意义
> 转换说明把二进制格式存储在计算机中的值转换成一系列字符（字符串）。以便于显示，例如数字76在计算机内部的存储格式
> 是二进制01001100，%d转换说明将其转换成字符7和6，并显示为76，转换说明并不是替换，而是翻译
- printf()函数的返回值
> printf()函数也有一个返回值，它返回打印字符的个数。如果有输出错误，printf()则返回一个负值
- scanf()函数
> C的多个输入函数之一，可以读取不同格式的数据，scanf()把输入的字符串转换成整数，浮点数，字符或字符串，而printf()正好相反，
> 把整数、浮点数、字符、字符串转换成显示在屏幕上的文本，printf()和scanf()函数的区别主要在参数列表
> printf()函数使用常量、变量、表达式，而scanf()函数使用指向变量的指针
> 1：如果scanf()读取基本类型的变量的值，在变量名前加一个&
> 2：如果用scanf()把字符串读入字符数组中，不要使用&
- 其他输入函数
> getchar(),fgets()
- printf()和scanf()的*修饰符
> 如果你不想预先指定字段宽度，希望通过程序来指定，那么可以用*修 
> 饰符代替字段宽度。但还是要用一个参数告诉函数，字段宽度应该是多少。 
> 也就是说，如果转换说明是%*d，那么参数列表中应包含*和 d对应的值。这 
> 个技巧也可用于浮点值指定精度和字段宽度
- 关键概念
- 什么是空白
> 空白包括空格、制表符和换行符。C 语言使用空白分隔记号。
> scanf()使用空白分隔连续的输入项

### chapter5: 运算符，表达式和语句
- 基本运算符
> = + - * /  虽然C没有指数运算符，但是C的标准数学库提供了pow()函数用于指数运算
> 一般来说，变量是可修改的左值，表达式是右值
- sizeof运算符和size_t类型
> sizeof以字节为单位返回运算对象大小，通常返回size_t类型(这是一个无符号整数类型)
> size_t不是新类型，是c语言定义的标准类型typedef double real; real deal,此时deal可以被判断为double类型
> size_t使用C99新增的%zd转换说明 -- 如果编译器不支持%zd，请将其改成%u或%lu
- 负数的求模
> C99规定“趋零截断”，如果第一个运算对象是正数，求模结果为正数，如果第一个运算对象为负数，则求模结果也为负数
> 11/5=2 11%5=1   11/-5=-2  11%-5=1  -11/5=-2 -11%5=-1 -11/-5=2 -11%-5=-1
> 事实上标准规定:无论何种情况，只要a,b都是整数值，便可通过a-(a/b)*b来计算a%b:
> -11%5=>-11-(-11/5)*5=-11-(-2)*5=-11+10=-1
- 自增自减运算符++ --
> ++/--出现在前面的叫做前缀模式，出现在后面的叫后缀模式
> 前缀模式先自增后运算，后缀模式先运算后递增
> 如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符
> 如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。
- 总结C的一些运算符
```
1:赋值运算符：= 将右边的值赋给左边的变量
2：算数运算符 + - * / % ++ --
3:其他运算符：sizeof 获得其右侧运算对象的大小
```
### chapter6: C控制语句：循环
> for while do while 
- 真、假
> 对c语言来说1==true 0==false,即表达式的值为1为真，表达式的值为0为假
> 一般而言，所有非0的值被视作真，只有0被视作假
- _Bool类型
> 只存储两个值，真（1）/假（0），如果把其他非零数值赋给_Bool类型的变量，该变量会被设置为1
> 这反映了C把所有的非零值都视为真
- 优先级与关系运算符
> 关系运算符的优先级比算数运算符（包括+、-）低，比赋值运算符高，
> 与其他大多数运算符一样，关系运算符的结合律也是从左往右，关系运算符之间有两种不同的优先级组
> 高优先级组：< <= > >= 低优先级组 ！=  ==
- 逗号运算符
> 逗号运算符把两个表达式连接成一个表达式，并保证最左边的表达式最先求值
> while循环： 初始化 while(测试){更新}  for(初始化;测试;更新)   初始化  do{更新 }while(测试)
- 字符数组
> 可以把字符串储存在char类型的数组中（一般而言，char类型数组的所有元素都储存char类型的值）。
> 如果char类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成了一个字符串

### chapter7: C控制语句：分支和跳转
- getchar()与putchar()
> getchar()函数不带任何参数，它从输入队列中返回下一个字符：ch=getchar()
> ==>scanf("%c",&ch);
> putchar()函数打印他的参数：putchar(ch):把ch的值作为字符打印出来
> ==》printf("%c",ch);
> 注意 getchar()和 putchar()不需要转换说明,因为它们只处理字符
- 逻辑运算符
> && 或 || 与  ！ 非  iso646.h将这些符号使用关键字替代  and or not
- 优先级
> !运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相 
> 同，只比圆括号的优先级低。&&运算符的优先级比||运算符高，但是两者的 
> 优先级都比关系运算符低，比赋值运算符高。因此，表达式a >b && b > c || 
> b > d相当于((a > b) && (b > c)) || (b > d)。
- 求值顺序(序列点与副作用)
> 除了两个运算符共享一个运算对象的情况外(3*x+2，其中x属于这个情况)，C 通常不保证先对复杂表达式中哪部分求值
> 但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右。&&和||运算符都是序列点，
> 所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。
> 而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值（短路）。
> 例如：while ( x++ < 10 && x + y < 20)    
> =》实际上，&&是一个序列点，这保证了在对&&右侧的表达式求值之前，已经递增了x。
- 范围
> 求90-100之间的判断：if (range >= 90 && range <= 100)，千万不要写成：
> (90<=x<=100),编译器这样理解：(90<=x)<=100，原因是逻辑运算符求值是从左往右：
> 导致前面的结果是一个布尔值（0/1）,即0<=100或者1<=100，这是一个恒为真的判断
- 条件运算符
> expression? expression1:expression2
- continue
> continue还可用作占位符,与其循环中不写任何内容，不如协商continue
> 通常情况下，把if的测试条件的关系反过来便可避免使用continue
- break
> 通常用来推出循环和选择
- 多重选择：switch/break
> 他是if elseif else的变体，用于多重选择
> break语句可用于循环和switch语句，但是continue只能用于循环中，如果switch在一个循环中
> 则可以使用continue,C语言中的switch圆括号中的值必须是一个整数值，包括char类型 (整形表达式)
- 多重标签
> 在switch中可以使用多个case,省略其中的break表示顺序执行,执行其中一个之后无需判断另一个,直接执行(因为其中没有break语句)
- switch一般注解
> 程序根据expression的值跳转至相应的case标签处。然后，执行剩下的所有语句，除非执行到break语句进行重定向。
> expression和case标签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。
> 如果没有case标签与expression的值匹配，控制则转至标有default的语句（如果 有的话）；
> 否则，将转至执行紧跟在switch语句后面的语句。
- goto
> goto part2;
> part2:printf("this is goto statement\n")

### chapter8: 字符输入/输出和输入验证
- 单字符IO:getchar()和putchar()
> 每次只处理一个字符，
- 缓冲输入、无缓冲输入
> 把若干个字符作为一个块输入要提高效率，无缓冲输入在游戏等立刻执行情况下有有用武之地
> 缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中
> 行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区
- 文件结尾
> 通常有两种方法，一种是在文件结尾标记特殊字符（例如ctrl+z）,另外一种是计算文件的大小，当达到指定大小时，
> 就算达到了文件末尾，在c语言中，无论哪种情况，当使用getchar()读取文件监测到结尾时都将返回EOF(End OF File)
> scanf()函数监测到文件结尾时也返回EOF
- 重定向输入（<）
> 假设已经编译了echo_eof.c  程序，并把可执行版本放入一个名为echo_eof（或者在Windows系统中名为echo_eof.exe）的文件中。
> 运行该程 序，输入可执行文件名:echo_eof(windows为echo_eof.exe),该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入。
> 现在，假设你要用该程序处理名为words的文本文件:echo_eof < words (windows为echo_eof.exe<word)
- gcc编译源文件
> gcc echo.c --如果没有指定文件名称，则生成a.out(linux) 或 a.exe(windows)。
> gcc 源文件名 -o 目标文件名  ：gcc hello.c -o target/hello会在 target 目录下生成 hello.exe 文件(Linux 系统生成 hello 可执行文件)
- 重定向输出（>）
> 现在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。
> 然后，输入以下命令并开始输入:echo_eof>mywords 
> 通常会擦除该文件的内容，然后替换新的内容,
> 记住在每行的末尾单击Enter键，这样才能把缓冲区的内容发送给程序
- 组合重定向
> 现在，假设你希望制作一份mywords文件的副本，并命名为savewords。
> 只需输入以下命令即可:echo_eof < mywords > savewords
> 下面的命令也起作用，因为命令与重定向运算符的顺序无关：
> echo_eof > savewords < mywords
- 关于重定向运算符
> 重定向运算符连接一个可执行程序（包括标准操作系统命令）和一个数据文件，
> 不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序。
> 使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件
- 追加运算符（>> 运算符）
> 该运算符可以把数据添加到现有文件的末尾,而 | 运算符能把一个文件的输出连接到另一个文件的输入
- 小结
> prog>file:将输出重定向至文件， prog<file:将输入重定向至文件
> prog>file1<file2 prog<file2>file1  这两种形式都是把file2作为输入、file1作为输出
- 输入验证
> 简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值。
> 使用转换说明（如%d或%f）限制了可接受输入的字符类型，而getchar()和使用%c的scanf()接受所有的字符。
- 关键概念
> C程序把输入作为传入的字节流。getchar()函数把每个字符解释成一个字符编码。
> scanf()函数以同样的方式看待输入，但是根据转换说明，它可以把字符输入转换成数值。
> 许多操作系统都提供重定向，允许用文件代替键盘输入，用文件代替显示器输出。

```
  许多程序使用 getchar()逐字符读取输入。通常，系统使用行缓冲输入，
  即当用户按下 Enter 键后输入才被传送给程序。按下Enter键也传送了一个换
  行符，编程时要注意处理这个换行符。ANSI C把缓冲输入作为标准
  
  通过标准I/O包中的一系列函数，以统一的方式处理不同系统中的不同
  文件形式，是C语言的特性之一。getchar()和  scanf()函数也属于这一系列。
  当检测到文件结尾时，这两个函数都返回  EOF（被定义在stdio.h头文件中）

  混合使用 getchar()和 scanf()时，如果在调用 getchar()之前，scanf()在输
  入行留下一个换行符，会导致一些问题。不过，意识到这个问题就可以在程
  序中妥善处理。
```
### chapter9: 函数
- 递归
> 最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。
> 这种形式的递归被称为尾递归（tail recursion），因为递归调用在函数的末尾。
> 尾递归是最简单的递归形式，因为它相当于循环
> 递归如果循环次数过多则会创建大量的变量（呈指数倍增长）
- 编译多源文件代码程序
> unix: cc file1.c file2.c 生成a.out文件，同时还生成file1.o file2.o目标文件
> 如果只改变file1.c 则合并：cc file1.c file2.o
> linux:gcc file1.c fil2.c   gcc file1.c file2.o
> windows:类似linux
- 查找地址：&运算符
- 间接运算符*
> *间接运算符用于找寻存贮在内存地址上的值，也叫解应用运算符
> 变量名和内存地址一一对应，当编译后就不存在变量名了，只有内存地址，name表示地址上的值，&name表示内存地址，它只能赋值给指针变量
> var=*pr 找出指针变量指向的值（pr实际上市一个内存地址（指针），存储的是（指向的是）某个变量的内存地址，*pr实际上就是对其指向的内存地址求值）
- 指针
> 指向存储类型变量地址
> 假设一个指针的变量名为pr,则 pr=&name (把name变量的内存地址赋值给pr)
> 语句 pr=&name, val=*pr ==>val=name,由此可见,使用地址和间接运算符可以间接完成
> 赋值语句
- 小结：与指针相关的运算符
> 地址运算符&：给出变量的地址，间接运算符*：给出存储在指针指向地址上的值
- 指针的声明
> 声明指针时必须指定指针所指向的变量的类型，因为不同的类型占用不同的存储空间，另外，占用相同存储空间的不同类型的数据
> 他们的存储方式可能也大相径庭
> int *pi  char *ch  float *f,*g 
- 关于int *pc
> 类型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量是一个指针 int *pc,声明的意思是pc是一个指针
> *pc是int类型，pc是指向int类型变量的指针，所以说*是解应用运算符，pc的值是一个地址，大多数系统内部，指针由无符号整数表示，
> 但是指针并不是整数类型，它是一种新类型，ANSI C 专门为其提供了%p格式的转换说明
- 变量：名称、地址、值
> 编写程序时，可以认为变量有两个属性，名称和值，计算机编译和加载程序后，认为变量也有两个属性，地址和值，地址就是变量在计算机内部的值
> 在许多语言中，地址都归计算机内部管理，对程序员隐藏，然而在c中，可以通过&运算符访问地址，通过*运算符获得地址上的值，
> 例如&ban表示变量ban的地址，使用名称获得的是变量的值，例如：printf("%d\n",ban)打印ban的值，使用*运算符即可获得存储在地址上的值，如果path=&ban
> 则*path表示存储在&ban地址上的值
- 概括
> 普通变量把值作为基本量，把地址作为通过&运算符获得的派生量，指针变量把地址作为基本量，把值作为通过*运算符获得的派生量

### chapter10:数组和指针
- 数组
> 对于自动存储类别的数组（在函数内部声明的，不带static的），如果不初始化数组，数组元素和未初始化的普通变量一样，其中存储的都是垃圾值，
> 蜀国初始化部分数组，剩余的元素就会被初始化为0,如果初始化项多于数组个数，则会报错，其实可以省略方括号中的数组个数，让编译器自动匹配数组大小
> 根据初始化时的数据项数目
- 指定初始化器
> 可以初始化指定的数组元素，例如初始化最后一个元素
> int arr[6]=[0,0,0,0,0,216],现在可以这样：int arr[6]={[5]=216}
- 数组边界
> 编译器不会报错，关于数组的边界需要程序员自己注意（编译器不检查，程序运行的更快）
> 数组的大小最好使用符号常量表示，这样做能确保整个程序中的数组大小始终一致
- 变长数组
> C99允许这么定义数组 int m=5 int arrs[m];此时arrs称为变长数组，它有一些限制，比如声明的时候不能初始化
- 多维数组
> float[5][12]
> 初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，
> 初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。
> 后面没有值初始化的元素被统一初始化为0
- 其他多维数组
> int box[10][20][30] 
> 可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表
> 例如，把上面声明的三维数组box想象成由10个二维数组（每个二维数组都是20行30列）堆叠起来。
> 还有一种理解box的方法是，把box看作数组的数组。也就是说，box内 含10个元素，
> 每个元素是内含20个元素的数组，这20个数组元素中的每个元素是内含30个元素的数组。
> 或者，可以简单地根据所需的下标值去理解数组
> 通常，处理三维数组要使用3重嵌套循环，处理四维数组要使用4重嵌套循环。对于其他多维数组，以此类推
- 指针和数组
> 指针再某种程度上把程序员想要表达的指令以更接近机器的方式表达，数组表示法其实是在变相的使用指针
> 例如：数组名是数组首元素的地址=》arrs==&arrs[0] (&是地址运算符)，他们都是常量，在运行过程中不会改变
> 可以把他们赋值给指针变量，然后可以修改指针变量的值
```
  指针的值是它所指向对象的地址，地址的表示方式依赖于计算机内部的硬件，许多计算机都是按字节编址
  意思是内存中的每个字节都按照顺序编号，这里，一个较大的对象的地址（如double类型的变量）通常是该对象第一个字节的地址
  在指针前面加上*运算符可以得到该指针所指向对象的值
  指针加1，只针对额值递增他所指向类型的大小（以字节为单位）
  下面的等式体现了c语言的灵活性：
    dates+2==&date[2] //相同的地址
    *(dates+2)=dates[2] //相同的值
  以上关系表明数组和指针关系十分密切，可以使用指针标识数组的元素和获取元素的值，从本质上看，同一个对象有两种表示法
  实际上C语言标准在描述数组表示法时确实借助了指针，也就是说定义arr[n]的意思是*(arr+n),可以认为*(arr+n)的意思是：
  到内存的arr位置，然后异动n个单元，检索存储在那里的值
  *(date3+2)==》dates的第三个元素
  *dates+2 dates的第一个元素的值+2  
```
- 函数、数组和指针
> 编写一个处理数组的函数，返回数组中所有元素之和：
> total=sum(members);//也许你会这样调用函数
```
  那么，该函数的原型是什么？记住，数组名是该数组首元素的地址，所以members实际上是一个存储int类型值的地址
  应该把它赋值给指针形式参数，即参数应该是一个指向int的指针
    int sum(int *arr);//对应的函数原型
  但是上面sum(members)只是获得了,数组首元素的地址，并未包含数组元素个数信息
    int sum(int *arr){
      int i;int total=0;
      for(i=0;i<10;i++){
        total+=arr[i];//这里arr[i]与*(arr+i)相同
      }
    }  
  既然可以使用指针表示数组名，也可以使用数组名表示指针：
  int sum(int *arr,int m)
  上方的形参表示数组的地址和数据类型，第二个参数表示原数组个数  
  在函数的形参中表示中，可以在函数原型表示上，使用int arr[]代替int *arr
  int sum(int[] arr,int m)//数组名是该数组首元素的地址，形参是一个与之匹配的指针或数组
  下面代码等价：
      int sum(int arr[],int m){}//arr是首位地址，可以赋给指针变量
      int sum(int *arr,int m){}//arr是一个指针
  
```
- 使用指针形参
> 函数处理数组，必须要知道何时开始何时结束，sum()函数使用一个指针表示数组开始，一个整数表示待处理数组个数
> 这并不是传递信息的唯一办法，还有一种方法是传递两个指针，第一个指针指明数组的开始处，第二个指针指明数组的结束处
- 指针表示法和数组表示法
> 处理数组的函数实际上使用指针作为参数，但是在编写这样的函数时，可以选择使用数组表示法还是指针表示法，
> 对于c语言，arr[i]和*(arr+i)这两个表达式都是等价的，无论arr是数组名还是指针变量，这两个表达式都没问题，但是只有是指针
> 变量时，才可以使用arr++这类表达式

- 指针操作
> 指针变量有8种基本的操作：
> 把一个地址赋值给指针  递增指针 递减指针 恢复为初始值 一个指针减去另一个指针 一个指针减去一个整数 解引用指针 获得指针地址
```
    赋值：可以把地址赋值给指针，例如使用数组名，带地址运算符&的变量名，另一个指针进行赋值，注意地址应该和指针类型兼容，不能把double类型的地址赋值给int类型的指针
    解引用：*运算符给出指针指向地址上存储的值，地址是内存中连续排列的大小单元，一般以字节为单位
    取址：和所有变量一样，指针变量也有自己的地址和值，对指针而言，&运算符给出指针本身的地址，指针变量本身表示该地址上的值
    指针与整数相加：整数与类型大小相乘，然后同指针地址相加：pt1+4==>urn[4],如果相加结果超出指针指向数组的范围，则计算结果为未定义的
    指针递增：递增指向数组元素的指针可以让指针指向数组的下一位元素相当于指针移动了该数据类型的字节数
    比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同的类型
    解引用未初始化的指针会有问题；int *pt1l  *pt1=5 会出问题，后面将5赋值给pt1指向的位置，但是pt1没有被初始化
        切记；创建一个指针变量时，系统只分配了存储指针本身的内存，并未分配存储数据的内存,因此在使用指针前，必须使用已分配的地址初始化它，
        例如可以使用一个现有的变量的地址初始化它（使用带指针形参的函数时，就属于这种情况）
            假设：int um[3];int *pt1,*pt2;//未初始化的指针
            有效：pt1++;pt2=pt1+2;pt2=um+1;
            无效：um++;pt2=pt2+pt1;pt2=urm+pt1
    基于这些有效的操作，c创建了数组指针，函数指针，指向指针的指针数组，指向函数的指针数组
    指针的第一个用法是在函数间传递信息（被调函数中改变主调函数的变量）
    指针的第二个用法是用在处理数组的函数中
```
- 保护数组中的数据
> 编写一个处理int类型的函数时，要选择是传递int类型的值还是传递指向int的指针，通常都是直接传递数值，只有在需要改变该数值的时候才会传递指针，数组别无选择
> 只能传递指针，因为这样做效率高，如果一个函数按值传递数组，则必须分配足够的空间来存储原数组的副本，然后把原数组的数据拷贝到新的数组中
> 如果把这个数组的地址传递给函数，让函数处理原数组则会效率更高，传递地址会导致一些问题，c通常都按照值传递数据，因为这样做可以保证数据的完整性，但是处理数组的函数
> 通常都会使用原始的数据,
- 对形式参数使用const
> 如果函数的意图不是修改数组中的内容，那么在函数的原型和定义中声明形式参数应该使用const,如果在函数中不小心使用指针更改了原始数据，编译器会捕获这个错误并生成错误信息
> 一般而言，如果编写的函数需要改变原始数组，在声明数组行参时不使用const,如果不需要改变，则应该使用const
- const的其他内容
> 可以创建const变量，const数组，const指针，和指向const的指针
> 无论是使用指针表示法还是使用数组表示法，都不允许pd修改它所指向的数据
```
  关于指针赋值和const需要注意的一些地方：
    1：把const的数据或非const数据的地址初始化为指向const的指针或为其赋值是合法的
      double rate[]={12.1,32,33.3};
      const double rates2[]={12.33,34.55,3445.33};
      const double *pc=rate;//有效
      pc=rates2;//有效
      pc=&rate[2];//有效
    2：只能把非const数据的地址赋值给普通指针
      double * ps2=rate;//有效
      ps2=rates2;//无效
      ps2=rate[2];//有效
    这个规则十分合理，否则通过指针就能改变const数组中的数据了
    C语言规定，使用非const标识符（如函数的形参）去修改const数据，如rates2,导致的结果是未定义的
    const可以声明并初始化一个不能指向别处的指针，关键是const的位置
    double rass[5]={12,12.33,23,44,4,6}
    double *const pcs=rass;//pcs指向数组的开始位置
    pcs=&rass[2];//不允许，因为该指针不能指向别处
    *pc=22.88;//ok，更改rass[0]的值
    可以用这种指针修改它所指向的值，但是他只能指向初始化的地址
    还可以在创建指针的时候使用两次const,该指针既不能改变它所指向的地址，也不能修改指向地址上的值
    double arrays[2]={12,23.44}
    const double *const pss=arrays;
    pss=&arrays[2];//不允许
    *pss=22.44;//不允许    
```
- 指针和多维数组
> 指针和多维数组有什么关系，处理多维数组的函数要用到指针
```
  * * * *
  * * * *
  假设有如下声明：int zippo[4][2];//内含int数组的数组
  然后数组的名称zippo是该数组首元素的地址，在本例中，zippo首元素是一个内涵两个int值的数组,所以zippo是这个内涵两个int值的数组的地址
  我们从指针进一步分析：
    因为zippo是数组首元素的地址，在本例中，所以zippo的值和&zippo[0]的值相同，而zippo[0]本身是一个内含两个int值的数组
    所以zippo[0]的值是和他内部的首元素（一个int值）的地址相同，简而言之：zippo是一个占用两个int大小的数组的地址，zippo[0]是一个占用一个int大小的整数的地址
    由于这个整数的地址和内含两个整数的数组的地址都开始于同一位置，所以zippo和zippo[0]的值相同
  
  给指针或地址+1，会增加对应类型大小的数值，在这方面zippo和zippo[0]不同，zippo的但愿是两个整形的数组，而zippo[0]的单元是int类型整数，所以zippo+1于zippo[0]+1的值不同，
  
  解引用一个指针（在指针前面使用*运算符）或在数组名后面使用带下标的[]运算，得到引用对象代表队额值，因为zippo[0]是该数组的首元素
  （zipp0[0][0]）的地址，所以*zippo[0]，代表存储在zippo[0][0]地址上的值，于此类似，*zippo代表该数组首元素（zippo[0]）的值，但是因为
  zippo[0]本身是一个int类型值的地址，该值的地址是：&zippo[0][0],所以*zippo==&zippo[0][0],==>**zippo==*&zippo[0][0]==zippo[0][0]
  由上可以得知，**zippo==int值，所以zippo是地址的地址，需要解引用两次才能得到原始int值
    地址的地址或者指针的指针就是双重间接的例子，详情见例子zippo1.c
```
- 数组指针理解
> 在我们的系统中，int是4字节，zippo[0]指向一个4字节的数据对象，zippo[0]+1,其值加4
> 数组名zippo是一个内含2个int类型值的数组的地址，所以zippo指向一个8字节的数据对象，zippo+1,
> 它所指向的地址加8个字节
- 取值
> zippo[0]和*zippo完全相同，然后对二维数组名解引用两次，得到存储在数组中的值，使用两个间接运算符* 或者使用两队方括号，或者一个*和【】都可以
- 指向多维数组的指针
> 如何编写一个指针变量pz指向一个二维数组如zippo,在编写处理类似zippo这样的二维数组的时候会用到这样的指针，
> 把指针声明为执向int的类型还不够，因为指向int的只能和zippo[0]的相匹配，说明该指针指向一个int类型的值，但是zippo是他的首元素地址，该元素是一个包含
> 两个int类型的一维数组，因此pz必须指向一个包含两个int类型值的数组，而不是指向一个int类型值，其声明如下：
```
  int (*pz)[2]; pz指向一个内含两个int类型值的数组
  以上代码将pz声明为指向一个数组的指针，该数组内含两个int类型的值，为什么使用（），因为【】优先级高于*
  考虑如下声明：
    int *ps[2];//ps是一个内含两个指针元素的数组，每个元素都指向int的指针
      由于【】优先级高于*，先于ps结合，所以ps成为一个内含两个元素的数组，然后*表示ps数组内含两个指针 ，最后int表示ps数组中的指针都指向int类型的值
      前方的则表示：*先于pz结合，因此声明的是一个指向数组（内含两个int类型的值）的指针
```
- 指针的兼容性
> 指针之间的赋值比数值类型值之间的赋值要严格的多，数据之间可以是使用类型转换，把int赋值给double类型变量
> 但是指针之间是不可以这样做的：如下：
```
  int n=5;
  double x;
  int *px=&n;
  double  *db=&x;
  x=n;//隐式类型转换
  db=px;//编译器错误
  更复杂的类型也是如此：
  int *pt;
  int(*pa)[3];
  int arr1[2][3];
  int arr2[3][2];
  int **p2;//一个指向指针的指针
  有如下语句
  pt=&arr1[0][0];//都是指向int的指针
  pt=arr1[0];//都是指向int的指针
  pt=arr1;//无效  pt 指向一个 int类型值，而ar1指向一个内含3和int类型元素的数组
  pa=arr1;//都是指向内含三个int值数组的指针
  pa=arr2;//无效 pa指向一个内含2个int类型元素的数组 arr2指向内含3个int类型元素的数组
  p2=&pt  ;//指针的指针
  *p2=arr2[0];都是指向int的指针
  p2=arr2;//无效 p2指向的指针指向int,arr2指向的指针是一个数组，类型不兼容
```
- 多重解引用让人费解
> 详情请见练习dereference.c
- C const和C++ const
```
  C和C++中const的用法很相似，但是并不完全相同。区别之一是，
  C++允许在声明数组大小时使用const整数，而C却不允许。区别之二是，
  C++的指针赋值检查更严格：
  const int y;
  const int * p2 = &y;
  int * p1;
  p1 = p2; // C++中不允许这样做，但是C可能只给出警告
  C++不允许把const指针赋给非const指针。而C则允许这样做，但是如果
  通过p1更改y，其行为是未定义的。  
```
- 函数和多维数组
> 要编写处理二维数组的函数，先要正确理解指针才能写出声明函数的形参
- 多维数组指针表示法
> 一般而言，声明一个指向N维数组的指针时，只能省略最左边的一堆方括号中的值：
> int sum4(int arr[][2][3][4]),因为第一队方括号只用来表明这是一个指针，而其他方括号用来
> 描述指针所指向数据对象的类型，下面的声明与上面的等价：
> int sum5(int (*arr)[2][3][4]),arr时一个指针，指向一个2*3*4的int数组
- 变长数组(VLA==>variable length array)
> C规定，数组的维数必须是常量，不能用变量代替cols, C99新增了变长数组，允许使用变量表示数组的维度
> int x=5;int y=4; int array[x][y]
```
  变长数组有一些限制：变长数组必须是自动存储类型，这意味着无论再函数中声明还是作为函数形参使用
  都不能使用static/extern存储类别说明符，而且不能在声明中初始化他们
  注意，变长数组不能改变大小，这里的变指的是创建数组时可以使用变量指定数组的维度，一旦创建了变长数组，
  他的大小则保持不变：
  int sums(int rows,int cols,int arr[rows][cols])//注意参数顺序，因为存在先后关系，不能先声明arr
  让然也可以省略形参名==》int sums(int,int,int arr[*][*]);//省略维度形参名，使用星号代替
  在函数定义的形参列表中声明的变长数组并未实际创建数组，和传统的语法类似，变长数组名实际上就是一个指针
  这说明带变长数组形参的函数实际上是在原数组中处理数组，因此可以修改传入的数组
  int thing [10][6]
  toset(10,6,thing)==>这里的thing指针就是传递函数形参的指针，可以根须函数形参来修改原数组
  int toset(int,int,int arr[*][*]) arr表示指向thing[0]的指针（thing是一个指针，指向长度为10的数组（内含6个int值））
  因为ar和thing都是指向thing[0]的指针，ar[0][0]与thing[0][0]访问的数据位置相同
```
- const和数组大小
> C99/C11 标准允许在声明变长数组时使用 const 变量。
> 所以该数组的定义必须是声明在块中的自动存储类别数组。
> 变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大 小。
> 普通 C数组都是静态内存分配，即在编译时确定数组的大小。
> 由于数组 大小是常量，所以编译器在编译时就知道了。
- 复合字面量
> 类似int字面量 4 ，double字面量2.33，char字面量'Y',字符串字面量“element”
> 数组也有字面量，普通声明数组 int div[2]={2,3},字面量表示为：（int[2]）{2,3}
> 其中：去掉声明中的数组名，留下的int[2]就是复合字面量的类型名
```
  初始化有数组名的数组时可以省略数组的大小，复合字面量也可以省略数组的大小，编译器会自动计算数组当前元素的个数
  int arr[]={2,4}
  (int[]){2.4}
  以为复合字面量是匿名的，所有不能先创建然后使用它，必须创建的同事使用它：
  int * pt1;
  pt1=(int[]){2,3}
  与有数组名的数组类似，复合字面量的类型名称也代表首元素的地址，所以可以把他赋值给
  指向int的指针没然后使用该指针，例如*pt1=2,pt1[1]=3
  还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数
  例如： total=sum((int[]){2,3});这样使用的好处是：把信息传入函数前不必创建数组
  还可以类似用于二维数组或多维数组: int(*pt2)[4],pt2=(int[2][4]{{1,2,3,4},{2,3,4,5}})
```
- 关键概念
```

```